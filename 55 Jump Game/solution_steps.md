---

### **Problem Statement (সমস্যাটা কী?)**

তোমাকে একটি নন-নেগেটিভ ইন্টিজার অ্যারে `nums` দেওয়া হবে। তুমি প্রাথমিকভাবে অ্যারের **প্রথম ইনডেক্সে (index 0)** আছো।

অ্যারের প্রতিটি `nums[i]` সংখ্যাটি হলো ওই পজিশন থেকে তুমি **সর্বোচ্চ (maximum)** কত ঘর লাফ দিতে পারবে।

তোমার কাজ হলো এটা নির্ধারণ করা যে তুমি লাফ দিতে দিতে অ্যারের **শেষ ইনডেক্সে (last index)** পৌঁছাতে পারবে কি না। `True` অথবা `False` রিটার্ন করতে হবে।

**উদাহরণ ১:**
*   **Input:** `nums = [2, 3, 1, 1, 4]`
*   **Output:** `True`
*   **ব্যাখ্যা:** তুমি ইনডেক্স 0 থেকে 1 ঘর লাফ দিয়ে ইনডেক্স 1-এ যেতে পারো (`nums[0]=2`, তাই ১ বা ২ ঘর লাফ দেওয়া সম্ভব)। তারপর ইনডেক্স 1 থেকে 3 ঘর লাফ দিয়ে সরাসরি শেষ ইনডেক্সে পৌঁছাতে পারো (`nums[1]=3`)।

**উদাহরণ ২:**
*   **Input:** `nums = [3, 2, 1, 0, 4]`
*   **Output:** `False`
*   **ব্যাখ্যা:** তুমি ইনডেক্স 0 থেকে লাফ দিয়ে 1, 2, বা 3-এ যেতে পারো।
    *   যদি ইনডেক্স 1-এ যাও (`nums[1]=2`), সেখান থেকে সর্বোচ্চ ইনডেক্স 3-এ যেতে পারবে।
    *   যদি ইনডেক্স 2-এ যাও (`nums[2]=1`), সেখান থেকেও সর্বোচ্চ ইনডেক্স 3-এ যেতে পারবে।
    *   যদি ইনডেক্স 3-এ যাও (`nums[3]=0`), তাহলে তুমি আটকে যাবে!
    *   সব পথেই তুমি ইনডেক্স 3-এ আটকে যাবে, যেখান থেকে আর এগোনো সম্ভব নয়। তাই শেষ ইনডেক্সে পৌঁছানো অসম্ভব।

---

### **ভুল ধারণা বনাম সঠিক ধারণা (Common Pitfall vs. The Right Idea)**

**ভুল ধারণা:** এই সমস্যাটি দেখে প্রথমে মনে হতে পারে এটি একটি ডাইনামিক প্রোগ্রামিং (DP) বা রিকার্সন (Recursion) সমস্যা, যেখানে আমাদের সব সম্ভাব্য পথ চেষ্টা করে দেখতে হবে। এই পথে সমাধান করা সম্ভব, কিন্তু তা অনেক জটিল এবং ধীরগতির হবে (Time Limit Exceeded হতে পারে)।

**সঠিক ধারণা (The Greedy Approach):** আমাদের সব পথ খুঁজে বের করার দরকার নেই। আমাদের শুধু এটা জানলেই হবে যে, প্রতিটি ধাপে আমরা **সর্বোচ্চ কতদূর পর্যন্ত পৌঁছাতে পারি (maximum reachable index)**।

মূল চিন্তাটা হলো: "আমি কি এমন কোনো যায়গায় আটকে যাচ্ছি যেখান থেকে আর সামনে এগোনো সম্ভব নয়?"

### **Greedy Algorithm**

আমরা একটি ভেরিয়েবল রাখব, ধরা যাক `farthest_reach`, যা ট্র্যাক করবে যে আমরা এখন পর্যন্ত সর্বোচ্চ কোন ইনডেক্স পর্যন্ত পৌঁছাতে পারি।

**অ্যালগরিদমের ধাপ (Steps of the Algorithm):**

1.  একটি ভেরিয়েবল `farthest_reach = 0` দিয়ে শুরু করো।
2.  অ্যারের শুরু থেকে শেষ পর্যন্ত একটি লুপ চালাবো লুপের প্রতিটি ধাপে `i` হলো আমাদের বর্তমান ইনডেক্স এবং `num` হলো `nums[i]`।
3.  **গুরুত্বপূর্ণ শর্ত:** লুপের ভেতরে প্রথমে চেক করবো, আমাদের বর্তমান ইনডেক্স `i` কি আমাদের `farthest_reach`-এর চেয়ে বড়?
    *   যদি `i > farthest_reach` হয়, তার মানে আমরা বর্তমান `i` ইনডেক্স পর্যন্ত পৌঁছাতেই পারিনি। আমরা আটকে গেছি। সুতরাং, আমরা আর সামনে এগোতে পারব না। সাথে সাথে `False` রিটার্ন করো।
4.  **রিচ আপডেট করা:** যদি আমরা `i` ইনডেক্স পর্যন্ত পৌঁছাতে পারি, তাহলে এই ঘর থেকে লাফ দিয়ে আমরা সর্বোচ্চ `i + num` ইনডেক্স পর্যন্ত যেতে পারব। আমরা আমাদের `farthest_reach`-কে এই নতুন সম্ভাব্য দূরত্বের সাথে তুলনা করে আপডেট করব।
    *   `farthest_reach = max(farthest_reach, i + num)`
5.  **সাফল্যের শর্ত:** যদি লুপটি কোনোবারও `i > farthest_reach` শর্তে না আটকে শেষ পর্যন্ত চলতে পারে, তার মানে আমরা কখনো আটকা পড়িনি এবং প্রতিটি ইনডেক্স পর্যন্ত পৌঁছানোর একটি উপায় ছিল। সুতরাং, শেষ ঘরেও পৌঁছানো সম্ভব। লুপ শেষে `True` রিটার্ন করো।

---

### **Python Code**

```python
def canJump(nums: list[int]) -> bool:
    # farthest_reach ট্র্যাক করবে আমরা সর্বোচ্চ কতদূর পৌঁছাতে পারি।
    farthest_reach = 0
    n = len(nums)
    
    for i, num in enumerate(nums):
        # যদি বর্তমান ইনডেক্স (i) আমাদের সর্বোচ্চ পৌঁছানোর সীমার বাইরে হয়,
        # তার মানে আমরা এখানে পৌঁছাতেই পারব না।
        if i > farthest_reach:
            return False
        
        # আমাদের সর্বোচ্চ পৌঁছানোর সীমাকে আপডেট করি।
        # বর্তমান অবস্থান (i) থেকে লাফ দিয়ে (num) আমরা i + num পর্যন্ত যেতে পারি।
        farthest_reach = max(farthest_reach, i + num)
        
        # একটি অপ্টিমাইজেশন: যদি আমাদের পৌঁছানোর সীমা শেষ ইনডেক্স বা তার বেশি হয়ে যায়,
        # তাহলে আর চেক করার দরকার নেই, আমরা নিশ্চিতভাবে পৌঁছাতে পারব।
        if farthest_reach >= n - 1:
            return True
            
    # যদি লুপ শেষ হয়, তার মানে আমরা শেষ পর্যন্ত পৌঁছেছি।
    return True

# Example Usage:
nums1 = [2, 3, 1, 1, 4]
print(f"For {nums1}, can we reach the end? {canJump(nums1)}") # Output: True

nums2 = [3, 2, 1, 0, 4]
print(f"For {nums2}, can we reach the end? {canJump(nums2)}") # Output: False
```

---

### **Dry Run**

চলো `nums = [3, 2, 1, 0, 4]` দিয়ে অ্যালগরিদমটি চালাই। `n = 5`।

*   **শুরুতে:** `farthest_reach = 0`
*   **i = 0, num = 3:**
    *   `i > farthest_reach`? (0 > 0) -> `False`। ঠিক আছে।
    *   `farthest_reach = max(0, 0 + 3) = 3`। এখন আমরা সর্বোচ্চ ইনডেক্স 3 পর্যন্ত যেতে পারি।
*   **i = 1, num = 2:**
    *   `i > farthest_reach`? (1 > 3) -> `False`। ঠিক আছে, আমরা এখানে পৌঁছাতে পারি।
    *   `farthest_reach = max(3, 1 + 2) = 3`। `farthest_reach` অপরিবর্তিত।
*   **i = 2, num = 1:**
    *   `i > farthest_reach`? (2 > 3) -> `False`। ঠিক আছে, আমরা এখানেও পৌঁছাতে পারি।
    *   `farthest_reach = max(3, 2 + 1) = 3`। `farthest_reach` এখনও অপরিবর্তিত।
*   **i = 3, num = 0:**
    *   `i > farthest_reach`? (3 > 3) -> `False`। ঠিক আছে, আমরা এখানেও পৌঁছাতে পারি।
    *   `farthest_reach = max(3, 3 + 0) = 3`। `farthest_reach` এখনও অপরিবর্তিত।
*   **i = 4, num = 4:**
    *   `i > farthest_reach`? (4 > 3) -> `True`! **এইখানে আমরা আটকে গেছি!**
    *   আমরা সর্বোচ্চ ইনডেক্স 3 পর্যন্ত পৌঁছাতে পেরেছি, কিন্তু আমাদের বর্তমান অবস্থান `i = 4`। তার মানে ইনডেক্স 4-এ পৌঁছানোর কোনো পথ আমাদের ছিল না।
    *   ফাংশন `False` রিটার্ন করবে।

### Complexity Analysis
*   **Time Complexity: O(N)**
    *   আমরা অ্যারেটির উপর দিয়ে শুধু একবার লুপ চালাই। তাই এটি একটি লিনিয়ার টাইম সমাধান।
*   **Space Complexity: O(1)**
    *   আমরা কোনো অতিরিক্ত ডেটা স্ট্রাকচার ব্যবহার করিনি, শুধুমাত্র কয়েকটি ভেরিয়েবল ব্যবহার করেছি। তাই স্পেস কমপ্লেক্সিটি কনস্ট্যান্ট।

### ইন্টারভিউ টিপস
*   **Greedy কেন কাজ করে?:** ব্যাখ্যা করো যে এই গ্রিডি অ্যাপ্রোচটি কাজ করে কারণ আমরা সবসময় আমাদের নাগালের সীমাকে সর্বোচ্চ করার চেষ্টা করছি। যদি কোনো একটি বিন্দুতে আমাদের বর্তমান অবস্থান আমাদের সর্বোচ্চ নাগালের বাইরে চলে যায়, তার মানে ওই বিন্দুতে পৌঁছানোর কোনো পথই ছিল না।
*   **Follow-up প্রশ্ন:** ইন্টারভিউয়ার তোমাকে এর পরের ধাপের প্রবলেম, **"Jump Game II" (LC 45)**, সম্পর্কে জিজ্ঞাসা করতে পারেন, যেখানে প্রশ্ন করা হয় "শেষ ঘরে পৌঁছানোর জন্য **ন্যূনতম (minimum)** কতগুলো লাফ লাগবে?"। এটি জানা থাকলে তোমার প্রস্তুতির গভীরতা প্রকাশ পাবে।