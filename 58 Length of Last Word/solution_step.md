### **Problem Statement**

তোমাকে একটি স্ট্রিং `s` দেওয়া হবে, যা শব্দ এবং স্পেস (space) দিয়ে গঠিত। তোমার কাজ হলো এই স্ট্রিং-এর **শেষ শব্দটির (last word)** দৈর্ঘ্য বের করা।

**Word কী?** একটি শব্দ হলো স্পেস নয় এমন অক্ষরগুলোর একটি ক্রম (sequence of non-space characters)।

**Example:**
*   `s = "Hello World"` -> **5** (শেষ শব্দ "World", যার দৈর্ঘ্য 5)
*   `s = "   fly me   to   the moon  "` -> **4** (শেষ শব্দ "moon", যার দৈর্ঘ্য 4)
*   `s = "luffy is still joyboy"` -> **6** (শেষ শব্দ "joyboy", যার দৈর্ঘ্য 6)

### **Core Challenges & Idea**

এই সমস্যার প্রধান চ্যালেঞ্জ হলো বিভিন্ন ধরনের স্পেস হ্যান্ডেল করা:
1.  **Trailing Spaces:** স্ট্রিং-এর শেষে থাকা অতিরিক্ত স্পেস (যেমন, `"word   "`)।
2.  **Leading Spaces:** স্ট্রিং-এর শুরুতে থাকা স্পেস।
3.  **Multiple Spaces between words:** শব্দের মাঝে একাধিক স্পেস।

সবচেয়ে কার্যকর ধারণাটি হলো, যেহেতু আমরা **শেষ** শব্দটি খুঁজছি, তাই স্ট্রিং-এর **শেষ থেকে শুরু করা** সবচেয়ে যৌক্তিক।

### **Approach 1: Using Library Functions (Sub-optimal)**

এটি সবচেয়ে সহজ কোডিং পদ্ধতি, কিন্তু ইন্টারভিউতে এটি সাধারণত গ্রহণ করা হয় না কারণ এটি মূল যুক্তিকে আড়াল করে ফেলে।

**Algorithm:**
1.  স্ট্রিং-এর শুরু এবং শেষ থেকে সব স্পেস বাদ দাও (trim)।
2.  স্ট্রিংটিকে স্পেসের ভিত্তিতে ভাগ করে (split) শব্দগুলোর একটি তালিকা তৈরি করো।
3.  তালিকার শেষ শব্দটি নাও এবং তার দৈর্ঘ্য রিটার্ন করো।

**C++ Code (using `stringstream`):**
```cpp
int lengthOfLastWord_library(string s) {
    stringstream ss(s);
    string word;
    vector<string> words;

    // স্ট্রিংকে শব্দে ভাগ করা
    while (ss >> word) {
        words.push_back(word);
    }

    if (words.empty()) {
        return 0;
    }
    
    // শেষ শব্দের দৈর্ঘ্য রিটার্ন করা
    return words.back().length();
}
```

**Complexity Analysis:**
*   **Time Complexity: O(N):** `stringstream` পুরো স্ট্রিংটি একবার পার্স করে।
*   **Space Complexity: O(N):** `words` ভেক্টরে সব শব্দ সংরক্ষণ করার জন্য অতিরিক্ত O(N) স্পেস লাগতে পারে।

**Verdict:** সহজবোধ্য, কিন্তু `in-place` নয় এবং অতিরিক্ত স্পেস ব্যবহার করে। ইন্টারভিউয়ার আপনাকে এটি ছাড়া সমাধান করতে বলবেন।

---

### **Approach 2: Iterate from the End (Optimal and Best Solution)**

এটিই সেরা এবং ইন্টারভিউয়ের জন্য উপযুক্ত সমাধান। এটি কোনো অতিরিক্ত স্পেস ব্যবহার করে না এবং সরাসরি সমস্যার সমাধান করে।

**Core Idea:**
আমরা দুটি ধাপে কাজ করব:
1.  **ধাপ ১:** স্ট্রিং-এর শেষ থেকে শুরু করে সব trailing spaces পার হয়ে শেষ শব্দের শেষ অক্ষরে পৌঁছাব।
2.  **ধাপ ২:** সেখান থেকে, আমরা বাম দিকে যেতে থাকব এবং অক্ষরের সংখ্যা গণনা করব, যতক্ষণ না আমরা একটি স্পেস বা স্ট্রিং-এর শুরুতে পৌঁছাই।

**Algorithm:**
1.  একটি `length` ভেরিয়েবল `0` দিয়ে শুরু করো।
2.  একটি পয়েন্টার `i` কে স্ট্রিং-এর শেষ ইনডেক্স (`s.length() - 1`) থেকে শুরু করো।
3.  **ধাপ ১ (Skip trailing spaces):** একটি `while` লুপ ব্যবহার করে `i`-কে বাম দিকে সরাও, যতক্ষণ `i >= 0` এবং `s[i] == ' '` থাকে। এই লুপ শেষে, `i` শেষ শব্দের শেষ অক্ষরটিকে নির্দেশ করবে (অথবা `-1` যদি স্ট্রিং-এ কোনো শব্দ না থাকে)।
4.  **ধাপ ২ (Count the word's length):** আরেকটি `while` লুপ চালাও, যতক্ষণ `i >= 0` এবং `s[i] != ' '` থাকে।
    *   প্রতিটি ইটারেশনে, `length`-কে `1` বাড়াও।
    *   `i`-কে `1` কমাও।
5.  `length` রিটার্ন করো।

**C++ Code:**
```cpp
int lengthOfLastWord(string s) {
    int length = 0;
    int i = s.length() - 1;

    // ধাপ ১: শেষ থেকে সব trailing spaces পার হওয়া
    while (i >= 0 && s[i] == ' ') {
        i--;
    }

    // ধাপ ২: শেষ শব্দের দৈর্ঘ্য গণনা করা
    while (i >= 0 && s[i] != ' ') {
        length++;
        i--;
    }

    return length;
}

```

**Complexity Analysis:**
*   **Time Complexity: O(N):** সবচেয়ে খারাপ ক্ষেত্রে (যেমন, একটি মাত্র বড় শব্দ), আমরা পুরো স্ট্রিংটি একবার ট্র্যাভার্স করি।
*   **Space Complexity: O(1):** আমরা শুধুমাত্র কয়েকটি ধ্রুবক ভেরিয়েবল ব্যবহার করেছি।

#### **Approach-2: Dry Run (`s = "  fly me to the moon  "`)**
1.  **Initialization:** `length = 0`, `i = 25` (স্ট্রিং-এর শেষ ইনডেক্স)।
2.  **ধাপ ১ (Skip trailing spaces):**
    *   `i = 25`, `s[25] = ' '`. `i` হয় `24`.
    *   `i = 24`, `s[24] = ' '`. `i` হয় `23`.
    *   ...
    *   `i = 21`, `s[21] = 'n'`. `s[21] != ' '`, লুপ শেষ। `i` এখন `21`।
3.  **ধাপ ২ (Count length):**
    *   `i = 21`, `s[21] = 'n'`. `length = 1`, `i = 20`.
    *   `i = 20`, `s[20] = 'o'`. `length = 2`, `i = 19`.
    *   `i = 19`, `s[19] = 'o'`. `length = 3`, `i = 18`.
    *   `i = 18`, `s[18] = 'm'`. `length = 4`, `i = 17`.
    *   `i = 17`, `s[17] = ' '`. `s[17] == ' '`, লুপ শেষ।
4.  **Final Result:** `length = 4` রিটার্ন হবে।

---

### **Summary of Approaches**

| Approach | Time Complexity | Space Complexity | Verdict  |
| :--- | :--- | :--- | :--- |
| **Library Functions** | O(N) | O(N) | সহজ কোডিং, কিন্তু ইন্টারভিউয়ের জন্য উপযুক্ত নয়। অতিরিক্ত স্পেস ব্যবহার করে। |
| **Iterate from End** | **O(N)** | **O(1)** | **সর্বোত্তম সমাধান।** কার্যকর, স্পেস-এফিসিয়েন্ট এবং সব এজ কেস সুন্দরভাবে হ্যান্ডেল করে। |