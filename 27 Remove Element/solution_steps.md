### **Problem Statement**

একটি ইন্টিজার অ্যারে `nums` এবং একটি ইন্টিজার `val` দেওয়া হবে।

কাজ হলো `nums` অ্যারে থেকে `val`-এর সমস্ত ocorrências (occurrences) **ইন-প্লেস (in-place)** সরিয়ে ফেলা। উপাদানগুলোর আপেক্ষিক ক্রম (relative order) পরিবর্তিত হতে পারে।

যেহেতু কিছু ভাষায় অ্যারের দৈর্ঘ্য পরিবর্তন করা সম্ভব নয়, তাই তোমাকে একটি ইন্টিজার `k` রিটার্ন করতে হবে, যা `val` সরানোর পর অ্যারেতে থাকা উপাদানের সংখ্যা নির্দেশ করে। অ্যারে `nums`-এর প্রথম `k`টি ঘরে চূড়ান্ত ফলাফল থাকতে হবে। `k`-এর পরের ঘরগুলোতে কী থাকবে, তা নিয়ে চিন্তা করতে হবে না।

**Example-1:**
*   `nums = [3, 2, 2, 3]`, `val = 3`
*   **result:** `k = 2`, এবং `nums`-এর প্রথম দুটি উপাদান হবে `[2, 2, _, _]`।

**Example-2:**
*   `nums = [0, 1, 2, 2, 3, 0, 4, 2]`, `val = 2`
*   **Result:** `k = 5`, এবং `nums`-এর প্রথম পাঁচটি উপাদান হবে `[0, 1, 3, 0, 4, _, _, _]` (ক্রম পরিবর্তিত হতে পারে)।

### **The Core Challenge**

এই সমস্যার প্রধান চ্যালেঞ্জ হলো **ইন-প্লেস** অপারেশন করা এবং O(1) অতিরিক্ত স্পেস ব্যবহার করে সমাধান করা। আমাদের লক্ষ্য হলো অ্যারেটি একবার মাত্র ট্র্যাভার্স করে কাজটি সম্পন্ন করা।

---

### **Approach 1: Two Pointers (Slow and Fast Pointers)**

এটি একটি খুবই সাধারণ এবং স্বজ্ঞাত টু-পয়েন্টার পদ্ধতি। এখানে একটি পয়েন্টার অ্যারে জুড়ে চলবে এবং অন্যটি শুধুমাত্র বৈধ উপাদানগুলোকে রাখার জন্য এগোবে।

**Core Concept:**
আমরা একটি "write pointer" (ধরা যাক `k` বা `slow`) রাখব, যা ট্র্যাক করবে পরবর্তী বৈধ উপাদানটি (অর্থাৎ, যা `val`-এর সমান নয়) কোথায় লেখা উচিত। আরেকটি "read pointer" (`i` বা `fast`) পুরো অ্যারেটি ট্র্যাভার্স করবে।

**Algorithm Step:**
1.  **Initialization:** একটি `write_pointer` (ধরা যাক `k`) `0` দিয়ে শুরু করো।
2.  **Iteration:** একটি `for` লুপ ব্যবহার করে `read_pointer` (`i`) দিয়ে পুরো `nums` অ্যারেটি ট্র্যাভার্স করো।
3.  **Core Logic:** লুপের ভেতরে, প্রতিটি উপাদান `nums[i]`-কে `val`-এর সাথে তুলনা করো।
    *   **যদি `nums[i]` `val`-এর সমান না হয়:**
        *   এর মানে এটি একটি বৈধ উপাদান যা আমাদের রাখতে হবে।
        *   এই উপাদানটিকে `nums[k]`-তম স্থানে বসাও: `nums[k] = nums[i]`।
        *   `write_pointer` `k`-কে এক ঘর এগিয়ে দাও: `k += 1`।
    *   **যদি `nums[i]` `val`-এর সমান হয়:**
        *   কিছুই করবে না। `read_pointer` `i` স্বাভাবিকভাবেই পরের ঘরে চলে যাবে, কিন্তু `write_pointer` `k` স্থির থাকবে।
4.  **Result:** লুপ শেষ হওয়ার পর, `k`-এর মানই হবে অ্যারেতে থাকা বৈধ উপাদানের সংখ্যা।

**Python Code:**
```python
def removeElement(nums: list[int], val: int) -> int:
    # k হলো write pointer, যা পরবর্তী বৈধ উপাদানের স্থান নির্দেশ করে
    k = 0
    
    # i হলো read pointer, যা পুরো অ্যারে ট্র্যাভার্স করে
    for i in range(len(nums)):
        # যদি বর্তমান উপাদানটি val-এর সমান না হয়
        if nums[i] != val:
            # এটিকে k-তম স্থানে বসাই
            nums[k] = nums[i]
            # এবং k-কে পরের ঘরের জন্য প্রস্তুত করি
            k += 1
            
    return k
```

**Complexity Analysis:**
*   **Time Complexity: O(N):** আমরা অ্যারেটি একবার মাত্র ট্র্যাভার্স করি।
*   **Space Complexity: O(1):** আমরা কোনো অতিরিক্ত অ্যারে ব্যবহার করিনি।

#### **Approach-1: Dry Run (`nums = [0, 1, 2, 2, 3, 0, 4, 2]`, `val = 2`)**

| `i` | `nums[i]` | `nums[i] != val`? | Action | `k` | `nums` (অবস্থা) |
|---|---|---|---|---|---|
| - | - | - | - | 0 | `[0, 1, 2, 2, 3, 0, 4, 2]` |
| 0 | 0 | `0 != 2` -> True | `nums[0] = 0`, `k++` | 1 | `[0, 1, 2, 2, 3, 0, 4, 2]` |
| 1 | 1 | `1 != 2` -> True | `nums[1] = 1`, `k++` | 2 | `[0, 1, 2, 2, 3, 0, 4, 2]` |
| 2 | 2 | `2 != 2` -> False | (কিছুই না) | 2 | `[0, 1, 2, 2, 3, 0, 4, 2]` |
| 3 | 2 | `2 != 2` -> False | (কিছুই না) | 2 | `[0, 1, 2, 2, 3, 0, 4, 2]` |
| 4 | 3 | `3 != 2` -> True | `nums[2] = 3`, `k++` | 3 | `[0, 1, 3, 2, 3, 0, 4, 2]` |
| 5 | 0 | `0 != 2` -> True | `nums[3] = 0`, `k++` | 4 | `[0, 1, 3, 0, 3, 0, 4, 2]` |
| 6 | 4 | `4 != 2` -> True | `nums[4] = 4`, `k++` | 5 | `[0, 1, 3, 0, 4, 0, 4, 2]` |
| 7 | 2 | `2 != 2` -> False | (কিছুই না) | 5 | `[0, 1, 3, 0, 4, 0, 4, 2]` |

**Final Result:** `k = 5`। `nums`-এর প্রথম ৫টি উপাদান: `[0, 1, 3, 0, 4]`।

---

### **Approach 2: Two Pointers (Moving from Both Ends)**

এই পদ্ধতিটি একটি সামান্য অপ্টিমাইজেশন, বিশেষ করে যখন অ্যারে থেকে সরানো উপাদানগুলোর সংখ্যা কম থাকে।

**Core Concept:**
আমরা একটি পয়েন্টার `i` শুরু থেকে এবং অন্য পয়েন্টার `n` শেষ থেকে চালাব। যখন `i`-তম উপাদানটি `val`-এর সমান হয়, তখন আমরা সেটিকে অ্যারের শেষ (`n-1`) উপাদানটির সাথে সোয়াপ (swap) করব এবং অ্যারের কার্যকরী দৈর্ঘ্য (`n`) এক কমিয়ে দেব।

**Algorithm Step:**
1.  **Initialization:** একটি পয়েন্টার `i = 0` নাও। `n` হবে অ্যারের বর্তমান কার্যকরী দৈর্ঘ্য, যা `len(nums)` দিয়ে শুরু হবে।
2.  **Iteration:** একটি `while` লুপ চালাও যতক্ষণ `i < n` থাকে।
3.  **Core Logic:**
    *   **যদি `nums[i]` `val`-এর সমান হয়:**
        *   `nums[i]`-কে অ্যারের শেষ উপাদান `nums[n-1]`-এর সাথে বদল করো (`swap`)।
        *   অ্যারের কার্যকরী দৈর্ঘ্য এক কমিয়ে দাও (`n -= 1`)।
        *   **গুরুত্বপূর্ণ:** `i`-কে এখানে বাড়াবে না। কারণ, সোয়াপ করে যে নতুন উপাদানটি `i`-তম স্থানে এসেছে, সেটিও `val`-এর সমান হতে পারে। তাই পরের ইটারেশনে আমাদের আবার `i`-তম স্থানটিই পরীক্ষা করতে হবে।
    *   **যদি `nums[i]` `val`-এর সমান না হয়:**
        *   উপাদানটি ঠিক জায়গায় আছে। `i`-কে এক ঘর এগিয়ে দাও (`i += 1`)।
4.  **Result:** লুপ শেষ হলে, `n`-এর মানই হবে নতুন দৈর্ঘ্য।

**Python Code:**
```python
def removeElement_optimized(nums: list[int], val: int) -> int:
    i = 0
    n = len(nums)
    
    while i < n:
        if nums[i] == val:
            # বর্তমান উপাদানকে শেষের উপাদানের সাথে বদল
            nums[i] = nums[n - 1]
            # কার্যকরী দৈর্ঘ্য কমানো
            n -= 1
        else:
            # উপাদান ঠিক থাকলে এগিয়ে যাওয়া
            i += 1
            
    return n
```

**Complexity Analysis:**
*   **Time Complexity: O(N):** প্রতিটি উপাদান একবার করে দেখা হয়। `i` এবং `n` একসাথে অ্যারেটিকে একবারই ট্র্যাভার্স করে।
*   **Space Complexity: O(1):** এটিও একটি ইন-প্লেস সমাধান।

**কোন পদ্ধতিটি কখন ভালো?**
*   **Approach 1:** এটি উপাদানের আপেক্ষিক ক্রম (relative order) বজায় রাখে (যেগুলো সরানো হয়নি)।
*   **Approach 2:** যখন সরানো উপাদানগুলোর সংখ্যা কম থাকে, তখন এটি কম সংখ্যক রাইট (write) অপারেশন করে, যা কিছু ক্ষেত্রে এটিকে দ্রুততর করতে পারে। তবে এটি উপাদানের ক্রম পরিবর্তন করে ফেলে।

---

### **Summary of Approaches**

| Approach (পদ্ধতি) | Time Complexity | Space Complexity | Notes (মন্তব্য) |
| :--- | :--- | :--- | :--- |
| **Two Pointers (Slow/Fast)** | O(N) | O(1) | স্বজ্ঞাত এবং কার্যকর। উপাদানের আপেক্ষিক ক্রম বজায় রাখে। |
| **Two Pointers (Both Ends)** | **O(N)** | **O(1)** | **সমাধান (কিছু ক্ষেত্রে অপ্টিমাইজড)।** যখন সরানো উপাদানের সংখ্যা কম থাকে, তখন কম রাইট অপারেশন করে। ক্রম পরিবর্তন করে। |