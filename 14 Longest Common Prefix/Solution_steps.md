### **Problem Statement**

তোমাকে একটি স্ট্রিং-এর অ্যারে `strs` দেওয়া হবে। তোমার কাজ হলো এই অ্যারের সমস্ত স্ট্রিং-এর মধ্যে থাকা **দীর্ঘতম সাধারণ উপসর্গ (Longest Common Prefix - LCP)** খুঁজে বের করা।

যদি কোনো সাধারণ উপসর্গ না থাকে, তাহলে একটি খালি স্ট্রিং `""` রিটার্ন করতে হবে।

**Prefix** একটি স্ট্রিং-এর উপসর্গ হলো তার শুরু থেকে নেওয়া যেকোনো দৈর্ঘ্যের একটি অংশ। যেমন, "flower"-এর উপসর্গগুলো হলো "f", "fl", "flo", "flow", "flowe", "flower"।

**Example:**
*   `strs = ["flower", "flow", "flight"]` -> `"fl"`
*   `strs = ["dog", "racecar", "car"]` -> `""` (কারণ কোনো সাধারণ উপসর্গ নেই)
*   `strs = ["apple"]` -> `"apple"` (কারণ একটি মাত্র স্ট্রিং আছে)

### **Core Challenges & Idea**

1.  **Empty Input:** যদি ইনপুট অ্যারে `strs` খালি থাকে, তাহলে কোনো উপসর্গ নেই।
2.  **Comparison Strategy:** মূল চ্যালেঞ্জ হলো কার্যকরভাবে কীভাবে সমস্ত স্ট্রিং-এর মধ্যে সাধারণ উপসর্গটি খুঁজে বের করা যায়।
3.  **Core Idea:** সাধারণ উপসর্গটি কখনোই অ্যারের সবচেয়ে ছোট স্ট্রিংটির চেয়ে বড় হতে পারে না। এই ধারণাটি আমাদের সার্চের সীমা নির্ধারণ করতে সাহায্য করে।

---

### **Approach 1: Horizontal Scanning**

এটি একটি স্বজ্ঞাত পদ্ধতি, যেখানে আমরা প্রথম স্ট্রিংটিকে আমাদের সম্ভাব্য LCP হিসেবে ধরে নিই এবং তারপর বাকি স্ট্রিংগুলোর সাথে তুলনা করে সেটিকে ছোট করতে থাকি।

**Algorithm:**
1.  **Edge Case:** যদি `strs` খালি থাকে, `""` রিটার্ন করো।
2.  `prefix`-কে `strs[0]` (প্রথম স্ট্রিং) দিয়ে শুরু করো।
3.  `i = 1` থেকে অ্যারের শেষ পর্যন্ত একটি লুপ চালাও।
4.  প্রতিটি `strs[i] `-এর জন্য, চেক করো `prefix` তার উপসর্গ কি না।
5.  একটি `while` লুপ ব্যবহার করে, যতক্ষণ না `strs[i]` `prefix` দিয়ে শুরু হচ্ছে (`strs[i].find(prefix) != 0`), ততক্ষণ `prefix`-এর শেষ থেকে একটি করে অক্ষর বাদ দিতে থাকো।
6.  যদি কোনো সময় `prefix` খালি হয়ে যায়, তার মানে কোনো সাধারণ উপসর্গ নেই। লুপটি `break` করে দাও।
7.  সবশেষে, `prefix` রিটার্ন করো।

**C++ Code:**
```cpp
string longestCommonPrefix_horizontal(vector<string>& strs) {
    if (strs.empty()) {
        return "";
    }

    string prefix = strs[0];
    for (size_t i = 1; i < strs.size(); ++i) {
        // যতক্ষণ strs[i] prefix দিয়ে শুরু না হচ্ছে
        while (strs[i].find(prefix) != 0) {
            // prefix থেকে শেষ অক্ষরটি বাদ দাও
            prefix = prefix.substr(0, prefix.length() - 1);
            if (prefix.empty()) {
                return "";
            }
        }
    }
    return prefix;
}
```

**Complexity Analysis:**
*   **Time Complexity: O(S)**, যেখানে `S` হলো অ্যারের সমস্ত স্ট্রিং-এর মোট অক্ষরের সংখ্যা। সবচেয়ে খারাপ ক্ষেত্রে (যেমন `["aaaa", "aaaa", "aaaa"]`), প্রতিটি `find` এবং `substr` অপারেশন সময় নেয়।
*   **Space Complexity: O(1):** (ফলাফল ছাড়া) কোনো অতিরিক্ত স্পেস ব্যবহার করা হয়নি।

---

### **Approach 2: Vertical Scanning (Character-by-Character Comparison)**

এটি সাধারণত হরিজোন্টাল স্ক্যানিং-এর চেয়ে বেশি কার্যকর, বিশেষ করে যখন LCP খুব ছোট এবং প্রথম স্ট্রিংটি খুব বড় হয়।

**Core Idea:**
আমরা প্রথম স্ট্রিং-এর প্রতিটি অক্ষরকে (`char`) কলাম-বাই-কলাম বাকি সব স্ট্রিং-এর সংশ্লিষ্ট অক্ষরের সাথে তুলনা করব।

**Algorithm:**
1.  **Edge Case:** যদি `strs` খালি থাকে, `""` রিটার্ন করো।
2.  প্রথম স্ট্রিং `strs[0]`-এর উপর দিয়ে একটি `for` লুপ চালাও (`i` দিয়ে, যা অক্ষর ইনডেক্স)।
3.  ভেতরে, আরেকটি `for` লুপ চালাও `j = 1` থেকে `strs.size()-1` পর্যন্ত (বাকি স্ট্রিংগুলোর জন্য)।
4.  **Core Logic:** দুটি জিনিস চেক করো:
    *   `i`-তম অক্ষরটি কি `strs[j]`-এর সীমার বাইরে চলে গেছে? (`i == strs[j].length()`)
    *   `strs[0]`-এর `i`-তম অক্ষরটি কি `strs[j]`-এর `i`-তম অক্ষরের সমান? (`strs[0][i] != strs[j][i]`)
5.  যদি উপরের যেকোনো একটি শর্ত পূরণ হয়, তার মানে সাধারণ উপসর্গটি `i`-এর আগেই শেষ হয়ে গেছে। `strs[0]`-এর প্রথম `i`টি অক্ষর (`strs[0].substr(0, i)`) রিটার্ন করো।
6.  যদি বাইরের লুপটি সম্পূর্ণ হয়, তার মানে প্রথম স্ট্রিংটিই হলো LCP। `strs[0]` রিটার্ন করো।

**C++ Code:**
```cpp
string longestCommonPrefix(vector<sstring>& strs) {
    if (strs.empty()) {
        return "";
    }

    // প্রথম স্ট্রিং-এর প্রতিটি অক্ষরের জন্য লুপ
    for (int i = 0; i < strs[0].length(); ++i) {
        char current_char = strs[0][i];
        
        // বাকি সব স্ট্রিং-এর সাথে তুলনা
        for (int j = 1; j < strs.size(); ++j) {
            // যদি অক্ষর ইনডেক্স সীমার বাইরে যায় বা অক্ষর না মেলে
            if (i == strs[j].length() || strs[j][i] != current_char) {
                // প্রথম i টি অক্ষরই হলো LCP
                return strs[0].substr(0, i);
            }
        }
    }
    
    // যদি লুপ শেষ হয়, তার মানে প্রথম স্ট্রিংটিই LCP
    return strs[0];
}
```

**Complexity Analysis:**
*   **Time Complexity: O(S)**, যেখানে `S` হলো অ্যারের সমস্ত স্ট্রিং-এর মোট অক্ষরের সংখ্যা। সবচেয়ে খারাপ ক্ষেত্রে (সব স্ট্রিং সমান), আমাদের সব অক্ষর পরীক্ষা করতে হবে।
*   **Space Complexity: O(1):** (ফলাফল ছাড়া)।

#### **Approach-2: Dry Run (`strs = ["flower", "flow", "flight"]`)**
1.  **i = 0, current_char = 'f'**:
    *   `j=1`: `strs[1][0]` ('f') == 'f'? Yes.
    *   `j=2`: `strs[2][0]` ('f') == 'f'? Yes.
2.  **i = 1, current_char = 'l'**:
    *   `j=1`: `strs[1][1]` ('l') == 'l'? Yes.
    *   `j=2`: `strs[2][1]` ('l') == 'l'? Yes.
3.  **i = 2, current_char = 'o'**:
    *   `j=1`: `strs[1][2]` ('o') == 'o'? Yes.
    *   `j=2`: `strs[2][2]` ('i') == 'o'? **No**.
    *   অমিল পাওয়া গেছে। `strs[0].substr(0, 2)` রিটার্ন করো, যা `"fl"`।
4.  **Final Result:** `"fl"`।

---

### **Approach 3: Sorting**

এটি একটি খুবই চতুর এবং সংক্ষিপ্ত সমাধান।

**Core Idea:**
যদি আমরা স্ট্রিং-এর অ্যারেটিকে লেক্সিকোগ্রাফিক্যালি (alphabetically) সর্ট করি, তাহলে LCP হবে **প্রথম স্ট্রিং** এবং **শেষ স্ট্রিং**-এর সাধারণ উপসর্গ। কেন? কারণ সর্ট করার পর, প্রথম এবং শেষ স্ট্রিং দুটি হবে একে অপরের থেকে সবচেয়ে ভিন্ন। যদি তাদের মধ্যে কোনো উপসর্গ সাধারণ থাকে, তবে সেটি বাকি সব স্ট্রিং-এর মধ্যেও সাধারণ হতে বাধ্য।

**Algorithm:**
1.  **Edge Case:** যদি `strs` খালি থাকে, `""` রিটার্ন করো।
2.  `strs` অ্যারেটিকে সর্ট করো।
3.  প্রথম স্ট্রিং (`first = strs[0]`) এবং শেষ স্ট্রিং (`last = strs.back()`) নাও।
4.  এই দুটি স্ট্রিং-এর মধ্যে সাধারণ উপসর্গটি খুঁজে বের করো। একটি লুপ চালিয়ে তাদের অক্ষরগুলো তুলনা করো যতক্ষণ না কোনো অমিল পাওয়া যায়।

**C++ Code:**
```cpp
string longestCommonPrefix_sorting(vector<string>& strs) {
    if (strs.empty()) {
        return "";
    }

    sort(strs.begin(), strs.end());
    
    string first = strs[0];
    string last = strs.back();
    int i = 0;

    while (i < first.length() && i < last.length() && first[i] == last[i]) {
        i++;
    }

    return first.substr(0, i);
}
```

**Complexity Analysis:**
*   **Time Complexity: O(S log S)** বা **O(N * m log N)**, যেখানে `m` হলো স্ট্রিং-এর গড় দৈর্ঘ্য। মূল সময় লাগে সর্টিং-এ। স্ট্রিং সর্টিং-এর কমপ্লেক্সিটি `O(N * m log N)` হতে পারে।
*   **Space Complexity: O(1)` or O(m log N)`:** সর্টিং অ্যালগরিদমের উপর নির্ভরশীল।

**Verdict:** খুবই সংক্ষিপ্ত এবং চতুর, কিন্তু সাধারণত ভার্টিকাল স্ক্যানিং-এর চেয়ে কম কার্যকর।

---

### **সারসংক্ষেপ (Summary of Approaches)**

| Approach | Time Complexity | Space Complexity | Verdict |
| :--- | :--- | :--- | :--- |
| **Horizontal Scanning**| O(S) | O(1) | স্বজ্ঞাত, কিন্তু কিছু এজ কেসে অদক্ষ হতে পারে। |
| **Vertical Scanning** | **O(S)** | **O(1)** | **সর্বোত্তম এবং সবচেয়ে নির্ভরযোগ্য সমাধান।** এটি অপ্রয়োজনীয় তুলনা এড়িয়ে যায়। |
| **Sorting** | O(N * m log N) | O(1) | খুবই চতুর এবং সংক্ষিপ্ত কোড, কিন্তু টাইম কমপ্লেক্সিটি বেশি। |