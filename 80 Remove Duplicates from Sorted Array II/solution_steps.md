
### **Problem Statement**

একটি **সর্টেড (sorted)** ইন্টিজার অ্যারে `nums` দেওয়া হবে। কাজ হলো এই অ্যারে থেকে ডুপ্লিকেট সংখ্যাগুলো **ইন-প্লেস (in-place)** সরিয়ে ফেলা, যাতে প্রতিটি ইউনিক উপাদান **সর্বোচ্চ দুইবার (at most twice)** থাকতে পারে। উপাদানগুলোর আপেক্ষিক ক্রম (relative order) একই থাকতে হবে।

একটি ইন্টিজার `k` রিটার্ন করতে হবে, যা ডুপ্লিকেট সরানোর পর অ্যারেতে থাকা উপাদানের সংখ্যা নির্দেশ করে। অ্যারে `nums`-এর প্রথম `k`টি ঘরে চূড়ান্ত ফলাফল থাকতে হবে। `k`-এর পরের ঘরগুলোতে কী থাকবে, তা নিয়ে চিন্তা করতে হবে না।

**Example-1:**
*   `nums = [1, 1, 1, 2, 2, 3]`
*   **Result:** `k = 5`, এবং `nums`-এর প্রথম পাঁচটি উপাদান হবে `[1, 1, 2, 2, 3, _]`।

**Example-2:**
*   `nums = [0, 0, 1, 1, 1, 1, 2, 3, 3]`
*   **Result:** `k = 7`, এবং `nums`-এর প্রথম সাতটি উপাদান হবে `[0, 0, 1, 1, 2, 3, 3, _, _]`।

### **LC 26 বনাম LC 80**

*   **LeetCode 26:** প্রতিটি উপাদানকে **একবার** রাখার অনুমতি ছিল।
*   **LeetCode 80:** প্রতিটি উপাদানকে **দুইবার** রাখার অনুমতি আছে।

এই "দুইবার" রাখার নিয়মটিই আমাদের অ্যালগরিদমের মূল শর্তটিকে পরিবর্তন করে দেয়।

---

### **Approach 1: Using an Extra Vector (Sub-optimal)**

এটি একটি সহজবোধ্য পদ্ধতি, যা `in-place` শর্তটি পূরণ করে না কিন্তু আলোচনার সূচনা হিসেবে ভালো।

**Core idea:**
একটি নতুন ভেক্টর `result` তৈরি করো। মূল `nums` ভেক্টরের উপর দিয়ে যাও এবং প্রতিটি উপাদানকে `result` ভেক্টরে যোগ করার আগে শর্ত পরীক্ষা করো।

**Algorithm Steps:**
1.  একটি খালি ভেক্টর `result` নাও।
2.  `nums` ভেক্টরের প্রতিটি `num`-এর জন্য লুপ চালাও।
3.  শর্তটি হলো: যদি `result`-এর আকার `2`-এর কম হয়, অথবা বর্তমান `num` `result`-এর শেষ থেকে দ্বিতীয় উপাদানের (`result[result.size() - 2]`) সমান না হয়, তাহলে `num`-কে `result`-এ যোগ করো।
4.  শেষে, `result` ভেক্টরটিকে `nums`-এ কপি করে দাও।

**C++ Code:**
```cpp
#include <iostream>
#include <vector>

int removeDuplicates_extra_space(vector<int>& nums) {
    if (nums.size() <= 2) {
        return nums.size();
    }

    vector<int> result;
    for (int num : nums) {
        if (result.size() < 2 || num != result[result.size() - 2]) {
            result.push_back(num);
        }
    }

    // result থেকে উপাদানগুলো আবার nums vector এ কপি করা
    for (size_t i = 0; i < result.size(); ++i) {
        nums[i] = result[i];
    }

    return result.size();
}
```

**Complexity Analysis:**
*   **Time Complexity: O(N):** `nums` ভেক্টর একবার ট্র্যাভার্স করা হয় এবং `result` একবার কপি করা হয়।
*   **Space Complexity: O(N):** `result` ভেক্টরের জন্য অতিরিক্ত O(N) স্পেস প্রয়োজন।

**Verdict:** এটি `in-place` শর্তটি পূরণ করে না, তাই এটি অপ্টিমাল সমাধান নয়।

---

### **Approach 2: Two Pointers (Optimal and Best Solution)**

এটিই সেরা এবং ইন্টারভিউয়ের জন্য উপযুক্ত সমাধান। LeetCode 26-এর Two-Pointers সমাধানের একটি সুন্দর পরিবর্তন এটি।

**Core idea:**
আমরা একটি `write_pointer` (ধরা যাক `k`) ব্যবহার করব, যা পরবর্তী বৈধ উপাদানটি কোথায় বসবে তা নির্দেশ করবে। আরেকটি `read_pointer` (`i`) পুরো অ্যারে জুড়ে চলবে।

যেহেতু প্রতিটি উপাদান সর্বোচ্চ দুইবার থাকতে পারে, তাই প্রথম দুটি উপাদান (`nums[0]` এবং `nums[1]`) সবসময়ই বৈধ। তাই আমরা `k` কে `2` থেকে শুরু করতে পারি।

**Algorithm:**
1.  **Edge Case:** যদি অ্যারের আকার `2` বা তার কম হয়, তবে কোনো কিছুই পরিবর্তন করার দরকার নেই। সরাসরি `nums.size()` রিটার্ন করো।
2.  **Initialization:** `write_pointer` `k`-কে `2` দিয়ে শুরু করো। কারণ প্রথম দুটি উপাদান সবসময়ই আমাদের ফলাফলে থাকবে।
3.  **Iteration:** একটি `for` লুপ ব্যবহার করে `read_pointer` `i` কে `2` থেকে অ্যারের শেষ পর্যন্ত চালাও।
4.  **Core Logic:** লুপের ভেতরে, বর্তমান উপাদান `nums[i]`-কে `nums[k-2]`-এর সাথে তুলনা করো।
    *   **কেন `k-2`?** `k` হলো পরবর্তী খালি ঘর। `k-1` এবং `k-2` হলো আমাদের ফলাফলে থাকা শেষ দুটি উপাদান। যদি `nums[i]` এবং `nums[k-2]` একই হয়, তার মানে `nums[k-2]`, `nums[k-1]`, এবং `nums[i]` তিনটিই একই সংখ্যা (কারণ অ্যারে সর্টেড)। এটি নিয়মের লঙ্ঘন।
    *   **সুতরাং, শর্তটি হলো:** যদি `nums[i]` এবং `nums[k-2]` **ভিন্ন** হয়, তবেই `nums[i]` একটি বৈধ উপাদান (হয় এটি একটি নতুন সংখ্যা, অথবা কোনো সংখ্যার দ্বিতীয় occurrence)।
    *   **যদি `nums[i] != nums[k-2]` হয়:**
        *   `nums[k] = nums[i]`।
        *   `k++`।
5.  **Result:** লুপ শেষে, `k`-এর মানই হবে নতুন দৈর্ঘ্য।

**C++ Code:**
```cpp
#include <bits/stdc++.h>
using namespace std;

int removeDuplicates(vector<int>& nums) {
    // Edge case: যদি vector এর আকার ২ বা তার কম হয়
    if (nums.size() <= 2) {
        return nums.size();
    }

    // k হলো write pointer. প্রথম দুটি উপাদান সবসময়ই বৈধ,
    // তাই k=2 থেকে শুরু।
    int k = 2; 

    // i হলো read pointer, যা তৃতীয় উপাদান থেকে শুরু করবে
    for (int i = 2; i < nums.size(); ++i) {
        // মূল শর্ত: বর্তমান উপাদানটি কি k-2 পজিশনে থাকা সংখ্যাটির চেয়ে ভিন্ন?
        // যদি ভিন্ন হয়, তার মানে এটি তৃতীয় ডুপ্লিকেট নয়।
        if (nums[i] != nums[k - 2]) {
            // সেটিকে k-তম স্থানে বসাই
            nums[k] = nums[i];
            // এবং k-কে পরের ঘরের জন্য প্রস্তুত করি
            k++;
        }
    }
    
    return k;
}

// Main function for testing
int main() {
    vector<int> nums1 = {1, 1, 1, 2, 2, 3};
    int k1 = removeDuplicates(nums1);
    cout << "k = " << k1 << ", nums = [";
    for (int i = 0; i < k1; ++i) {
        cout << nums1[i] << (i == k1 - 1 ? "" : ", ");
    }
    cout << "]" << endl;

    vector<int> nums2 = {0, 0, 1, 1, 1, 1, 2, 3, 3};
    int k2 = removeDuplicates(nums2);
    cout << "k = " << k2 << ", nums = [";
    for (int i = 0; i < k2; ++i) {
        cout << nums2[i] << (i == k2 - 1 ? "" : ", ");
    }
    cout << "]" << endl;

    return 0;
}
```

**Complexity Analysis:**
*   **Time Complexity: O(N):** আমরা অ্যারেটি একবার মাত্র ট্র্যাভার্স করি।
*   **Space Complexity: O(1):** আমরা কোনো অতিরিক্ত স্পেস ব্যবহার করিনি।

**Verdict:** এটিই **সর্বোত্তম সমাধান**, যা `in-place` শর্ত পূরণ করে এবং লিনিয়ার টাইমে কাজ করে।

#### **Approach-2: Dry Run (`nums = [0, 0, 1, 1, 1, 1, 2, 3, 3]`)**

| `i` | `nums[i]` | `k` | `nums[k-2]` | `nums[i] != nums[k-2]`? | Action | `nums` |
|---|---|---|---|---|---|---|
| - | - | 2 | - | - | - | `[0,0,1,1,1,1,2,3,3]` |
| 2 | 1 | 2 | `nums[0]=0` | `1 != 0` -> True | `nums[2]=1`, `k++` | `[0,0,1,1,1,1,2,3,3]` `k=3` |
| 3 | 1 | 3 | `nums[1]=0` | `1 != 0` -> True | `nums[3]=1`, `k++` | `[0,0,1,1,1,1,2,3,3]` `k=4` |
| 4 | 1 | 4 | `nums[2]=1` | `1 != 1` -> False | (কিছুই না) | `[0,0,1,1,1,1,2,3,3]` `k=4` |
| 5 | 1 | 4 | `nums[2]=1` | `1 != 1` -> False | (কিছুই না) | `[0,0,1,1,1,1,2,3,3]` `k=4` |
| 6 | 2 | 4 | `nums[2]=1` | `2 != 1` -> True | `nums[4]=2`, `k++` | `[0,0,1,1,2,1,2,3,3]` `k=5` |
| 7 | 3 | 5 | `nums[3]=1` | `3 != 1` -> True | `nums[5]=3`, `k++` | `[0,0,1,1,2,3,2,3,3]` `k=6` |
| 8 | 3 | 6 | `nums[4]=2` | `3 != 2` -> True | `nums[6]=3`, `k++` | `[0,0,1,1,2,3,3,3,3]` `k=7` |

**Final Result:** `k = 7`। `nums`-এর প্রথম ৭টি উপাদান: `[0, 0, 1, 1, 2, 3, 3]`।