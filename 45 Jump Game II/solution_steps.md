---

### **Problem Statement**

তোমাকে একটি নন-নেগেটিভ ইন্টিজার অ্যারে `nums` দেওয়া হবে। তুমি প্রাথমিকভাবে অ্যারের **প্রথম ইনডেক্সে (index 0)** আছো। অ্যারের প্রতিটি সংখ্যা `nums[i]` হলো ওই অবস্থান থেকে তুমি **সর্বোচ্চ** কত ঘর লাফ দিতে পারবে।

তোমার কাজ হলো অ্যারের **শেষ ইনডেক্সে** পৌঁছানোর জন্য **ন্যূনতম (minimum)** কতগুলো লাফ লাগবে, তা বের করা।

একটি গুরুত্বপূর্ণ বিষয়: তোমাকে নিশ্চিত করা হয়েছে যে তুমি **সবসময়ই** শেষ ইনডেক্সে পৌঁছাতে পারবে।

**উদাহরণ ১:**
*   **Input:** `nums = [2, 3, 1, 1, 4]`
*   **Output:** `2`
*   **ব্যাখ্যা:** সবচেয়ে কম লাফে পৌঁছানোর উপায় হলো:
    1.  ইনডেক্স 0 থেকে 1 ঘর লাফ দিয়ে ইনডেক্স 1-এ যাও (`nums[0]=2`)।
    2.  ইনডেক্স 1 থেকে 3 ঘর লাফ দিয়ে শেষ ইনডেক্সে (ইনডেক্স 4) যাও (`nums[1]=3`)।
    *   মোট লাফ লাগলো: 2টি।

**উদাহরণ ২:**
*   **Input:** `nums = [2, 3, 0, 1, 4]`
*   **Output:** `2`
*   **ব্যাখ্যা:** ইনডেক্স 0 থেকে 2 ঘর লাফ দিয়ে সরাসরি ইনডেক্স 2-এ যাওয়া যায়, কিন্তু সেটা সেরা পথ নয়। সেরা পথ হলো:
    1.  ইনডেক্স 0 থেকে 1 ঘর লাফ দিয়ে ইনডেক্স 1-এ যাও।
    2.  ইনডেক্স 1 থেকে 3 ঘর লাফ দিয়ে শেষ ইনডেক্সে যাও।
---
---

### **Jump Game I বনাম Jump Game II**

*   **Jump Game I:** প্রশ্ন ছিল "শেষ পর্যন্ত পৌঁছানো **সম্ভব** কি না?" (একটি `True`/`False` উত্তর)।
*   **Jump Game II:** প্রশ্ন হলো "**ন্যূনতম কতগুলো লাফে** পৌঁছানো সম্ভব?" (একটি সংখ্যাসূচক উত্তর)।

এই "ন্যূনতম" শব্দটিই সমস্যাটিকে আরও আকর্ষণীয় করে তোলে।


---

### **Approach 1: Dynamic Programming (DP) - বটম-আপ পদ্ধতি**

এটি একটি ক্লাসিক্যাল পদ্ধতি, যা "ন্যূনতম ধাপ" জাতীয় সমস্যা সমাধানের জন্য প্রায়ই ব্যবহৃত হয়। যদিও এটি সেরা সমাধান নয়, তবে এটি একটি ভালো সূচনা বিন্দু।

**​̲𝑻​̲𝒉​̲𝒆​̲ ​̲𝑪​̲𝒐​̲𝒓​̲𝒆​̲ ​̲𝑰​̲𝒅​̲𝒆​̲𝒂:**
আমরা একটি `dp` অ্যারে তৈরি করব, যেখানে `dp[i]` হবে **ইনডেক্স `i`-তে পৌঁছানোর জন্য ন্যূনতম লাফের সংখ্যা**। আমাদের লক্ষ্য হলো `dp[n-1]` (শেষ ঘরের মান) বের করা।

**𝙎𝙩𝙚𝙥𝙨:**
1.  **Initialization:** একটি `dp` অ্যারে তৈরি করো যার সাইজ হবে `n` (nums অ্যারের সমান)। প্রতিটি ঘরের মান ইনফিনিটি (`float('inf')`) দিয়ে পূর্ণ করো। `dp[0]`-এর মান `0` হবে, কারণ প্রথম ঘরে পৌঁছাতে কোনো লাফ লাগে না।
2.  **Iteration:** দুটি নেস্টেড লুপ চালাও।
    *   বাইরের লুপটি `i` (লক্ষ্য ইনডেক্স) 1 থেকে `n-1` পর্যন্ত চলবে।
    *   ভেতরের লুপটি `j` (শুরুর ইনডেক্স) 0 থেকে `i-1` পর্যন্ত চলবে।
3.  **Core Logic:** ভেতরের লুপে, আমরা চেক করব যে `j` ইনডেক্স থেকে `i` ইনডেক্সে এক লাফে পৌঁছানো সম্ভব কি না।
    *   শর্তটি হলো: `j + nums[j] >= i`।
    *   যদি পৌঁছানো সম্ভব হয়, তাহলে `i`-তে পৌঁছানোর জন্য মোট লাফের সংখ্যা হবে `dp[j] + 1`। আমরা এই মানটিকে `dp[i]`-এর বর্তমান মানের সাথে তুলনা করে ন্যূনতমটি রাখব।
    *   `dp[i] = min(dp[i], dp[j] + 1)`
4.  **Result:** লুপ শেষে, `dp[n-1]`-এর মানই হবে আমাদের উত্তর।

**Python Code:**
```python
def jump_dp(nums: list[int]) -> int:
    n = len(nums)
    if n <= 1:
        return 0
    
    dp = [float('inf')] * n
    dp[0] = 0
    
    for i in range(1, n):
        for j in range(i):
            # যদি j থেকে i-তে পৌঁছানো যায়
            if j + nums[j] >= i:
                dp[i] = min(dp[i], dp[j] + 1)
                
    return dp[n-1]
```

**𝗖𝗼𝗺𝗽𝗹𝗲𝘅𝗶𝘁𝘆 𝗔𝗻𝗮𝗹𝘆𝘀𝗶𝘀:**
* **𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚: 𝑶(𝑵²):** দুটি নেস্টেড লুপের কারণে টাইম কমপ্লেক্সিটি কোয়াড্রেটিক।
* **𝙎𝙥𝙖𝙘𝙚 𝘾𝙤𝙢𝙥𝙡𝙚𝙭𝙞𝙩𝙮: 𝙊(𝑵):** `dp` অ্যারে সংরক্ষণের জন্য লিনিয়ার স্পেস প্রয়োজন।

**Verdict:** এটি একটি কার্যকর সমাধান, কিন্তু বড় ইনপুটের জন্য এটি "Time Limit Exceeded" (TLE) দেবে।

---

### **Approach 2: Breadth-First Search (BFS)**

এই সমস্যাটিকে একটি গ্রাফের শর্টেস্ট পাথ সমস্যা হিসেবেও দেখা যায়। প্রতিটি ইনডেক্স একটি নোড এবং প্রতিটি সম্ভাব্য লাফ একটি এজ। যেহেতু আমরা ন্যূনতম লাফ খুঁজছি, BFS একটি স্বাভাবিক পছন্দ।

**​̲𝑻​̲𝒉​̲𝒆​̲ ​̲𝑪​̲𝒐​̲𝒓​̲𝒆​̲ ​̲𝑰​̲𝒅​̲𝒆​̲𝒂:**
আমরা লেভেল বাই লেভেল ট্র্যাভার্স করব। প্রতিটি লেভেল একটি লাফের সমতুল্য।
*   লেভেল 0: শুধু ইনডেক্স `0`।
*   লেভেল 1: ইনডেক্স `0` থেকে এক লাফে যেখানে যেখানে যাওয়া যায়।
*   লেভেল 2: লেভেল 1-এর নোডগুলো থেকে এক লাফে যেখানে যেখানে যাওয়া যায়।

**𝙎𝙩𝙚𝙥𝙨:**
1.  **Initialization:** একটি `queue` এবং একটি `visited` সেট/অ্যারে নাও। `queue`-তে `(index=0, jumps=0)` রাখো এবং `0`-কে `visited` হিসেবে মার্ক করো।
2.  **BFS Loop:** `queue` খালি না হওয়া পর্যন্ত লুপ চালাও।
3.  **Process Level:** `queue` থেকে একটি `(current_index, current_jumps)` বের করো।
4.  **Check Goal:** যদি `current_index` শেষ ইনডেক্স হয় (`n-1`), তাহলে `current_jumps`-ই আমাদের উত্তর।
5.  **Explore Neighbors:** `current_index` থেকে `nums[current_index]` পরিমাণ লাফ দিয়ে যতগুলো নতুন ইনডেক্সে (`next_index`) যাওয়া যায়, সেগুলোর জন্য লুপ চালাও।
    *   যদি `next_index` আগে `visited` না হয়ে থাকে, তবে তাকে `visited` মার্ক করো এবং `(next_index, current_jumps + 1)` `queue`-তে যোগ করো।

**Python Code (Conceptual):**
```python
from collections import deque

def jump_bfs(nums: list[int]) -> int:
    n = len(nums)
    if n <= 1:
        return 0
    
    queue = deque([(0, 0)]) # (index, jumps)
    visited = {0}
    
    while queue:
        current_idx, jumps = queue.popleft()
        
        if current_idx == n - 1:
            return jumps
            
        # Explore all reachable indices
        for i in range(1, nums[current_idx] + 1):
            next_idx = current_idx + i
            if next_idx < n and next_idx not in visited:
                visited.add(next_idx)
                queue.append((next_idx, jumps + 1))
    return -1 # Should not happen based on problem statement
```

**𝗖𝗼𝗺𝗽𝗹𝗲𝘅𝗶𝘁𝘆 𝗔𝗻𝗮𝗹𝘆𝘀𝗶𝘀:**
* **𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚: 𝑶(𝑵²):** সবচেয়ে খারাপ ক্ষেত্রে (যেমন `[N, 1, 1, ...]`), প্রথম নোড থেকেই প্রায় `N` টি নতুন নোড `queue`-তে যোগ হতে পারে।
* **𝙎𝙥𝙖𝙘𝙚 𝘾𝙤𝙢𝙥𝙡𝙚𝙭𝙞𝙩𝙮: 𝙊(𝑵):** `queue` এবং `visited` সেটের জন্য লিনিয়ার স্পেস লাগতে পারে।

**Verdict:** এটিও TLE দিতে পারে, কিন্তু এটি Greedy সমাধানের পেছনের মূল ধারণাটি তৈরি করে।

---

#### **Approach 3: Optimized Greedy (সেরা এবং ইন্টারভিউয়ের জন্য উপযুক্ত সমাধান)**

এটি BFS ধারণার একটি অত্যন্ত কার্যকর এবং স্পেস-এফিসিয়েন্ট ইমপ্লিমেন্টেশন। আমরা একটি এক্সপ্লিসিট `queue` ব্যবহার না করে, কয়েকটি ভেরিয়েবলের মাধ্যমে "লেভেল"-এর সীমানা ট্র্যাক করি।

**​̲𝑻​̲𝒉​̲𝒆​̲ ​̲𝑪​̲𝒐​̲𝒓​̲𝒆​̲ ​̲𝑰​̲𝒅​̲𝒆​̲𝒂:**
আমরা "লাফ বাই লাফ" বা "উইন্ডো বাই উইন্ডো" এগোব। প্রতিটি লাফে, আমরা পরবর্তী লাফের জন্য আমাদের নাগালকে সর্বোচ্চ করার চেষ্টা করব।

**ভেরিয়েবলগুলোর অর্থ:**
*   `jumps`: আমরা মোট কতগুলো লাফ দিয়েছি। এটি আমাদের চূড়ান্ত উত্তর।
*   `current_reach`: **বর্তমান লাফ দিয়ে** আমরা সর্বোচ্চ কোন ইনডেক্স পর্যন্ত পৌঁছাতে পারি। এটি আমাদের বর্তমান "লেভেল" বা "উইন্ডো"-এর শেষ সীমানা।
*   `farthest_reach`: **পরবর্তী লাফের জন্য** আমরা সর্বোচ্চ কোন ইনডেক্স পর্যন্ত পৌঁছানোর প্রস্তুতি নিচ্ছি।

**Steps:**
1.  **Initialization:** `jumps = 0`, `current_reach = 0`, `farthest_reach = 0` দিয়ে শুরু করো।
2.  **Iteration:** অ্যারের উপর দিয়ে একটি লুপ চালাও। **গুরুত্বপূর্ণ:** লুপটি অ্যারের শেষ ঘরের **আগের ঘর** পর্যন্ত চলবে (`for i in range(len(nums) - 1)`), কারণ শেষ ঘরে পৌঁছানোর পর আর লাফ দেওয়ার দরকার নেই।
3.  **Greedy Choice:** প্রতিটি `i`-তম ঘরে দাঁড়িয়ে, আমরা একটি লোভী সিদ্ধান্ত নেব। আমরা দেখব, এই ঘর থেকে লাফ দিলে আমরা সর্বোচ্চ কতদূর যেতে পারি (`i + nums[i]`)। এই মানটিকে আমাদের এখন পর্যন্ত পাওয়া `farthest_reach`-এর সাথে তুলনা করে সর্বোচ্চটি রাখব।
    *   `farthest_reach = max(farthest_reach, i + nums[i])`
    *   এর মানে হলো, আমরা বর্তমান লাফের সীমানার মধ্যে থেকে পরবর্তী লাফের জন্য সেরা লঞ্চিং প্যাড খুঁজছি।
4.  **Jump Condition (কখন লাফ দেব?):** যখন আমাদের বর্তমান অবস্থান `i` আমাদের `current_reach`-এর সমান হয়ে যায়, তার মানে আমরা আমাদের বর্তমান লাফের সীমানার শেষ প্রান্তে পৌঁছে গেছি। এর পরে এগোতে হলে আমাদের **অবশ্যই একটি নতুন লাফ দিতে হবে**।
    *   যদি `i == current_reach` হয়:
        *   `jumps` এর মান `1` বাড়াও (কারণ আমরা একটি লাফ সম্পন্ন করলাম)।
        *   আমাদের নতুন সীমানা (new `current_reach`) হবে `farthest_reach`। কারণ, আমরা আগের লাফের সীমানার মধ্যে থেকে সর্বোচ্চ এতদূর পর্যন্ত পৌঁছানোর ব্যবস্থা করে ফেলেছি।

**Dry Run (উদাহরণ: `nums = [2, 3, 1, 1, 4]`):**
*   **শুরুতে:** `jumps = 0`, `current_reach = 0`, `farthest_reach = 0`
*   **i = 0:**
    *   `farthest_reach = max(0, 0 + 2) = 2`।
    *   `i == current_reach`? (0 == 0) -> হ্যাঁ।
        *   `jumps = 1` (প্রথম লাফ দিলাম)।
        *   `current_reach = farthest_reach = 2` (এখন আমাদের সীমানা ইনডেক্স 2)।
*   **i = 1:**
    *   `farthest_reach = max(2, 1 + 3) = 4`। (পরবর্তী লাফের জন্য আমরা ইনডেক্স 4 পর্যন্ত পৌঁছানোর লক্ষ্য ঠিক করলাম)।
    *   `i == current_reach`? (1 == 2) -> না।
*   **i = 2:**
    *   `farthest_reach = max(4, 2 + 1) = 4`।
    *   `i == current_reach`? (2 == 2) -> হ্যাঁ।
        *   `jumps = 2` (দ্বিতীয় লাফ দিলাম)।
        *   `current_reach = farthest_reach = 4`।
*   লুপটি `i=3` পর্যন্ত চলবে। `i=4` (শেষ ঘর) পর্যন্ত চলার আগেই শেষ হবে।
*   লুপ শেষে `jumps = 2` রিটার্ন হবে।

**Python Code:**
```python
def jump_greedy(nums: list[int]) -> int:
    if len(nums) <= 1: return 0
    jumps = 0
    current_reach = 0
    farthest_reach = 0
    for i in range(len(nums) - 1):
        farthest_reach = max(farthest_reach, i + nums[i])
        if i == current_reach:
            jumps += 1
            current_reach = farthest_reach
    return jumps
```

**Complexity Analysis:**
*   **Time Complexity: O(N)** - অ্যারেটির উপর দিয়ে শুধু একবার লুপ চালানো হয়।
*   **Space Complexity: O(1)** - কোনো অতিরিক্ত মেমরি ব্যবহার করা হয় না।

---

### সারসংক্ষেপ (Summary of Approaches)

| Approach              | Time Complexity | Space Complexity | Verdict                                                              |
| --------------------- | --------------- | ---------------- | -------------------------------------------------------------------- |
| **Dynamic Programming** | O(N²)           | O(N)             | সহজবোধ্য কিন্তু অদক্ষ। বড় ইনপুটের জন্য TLE দেবে।                   |
| **BFS**               | O(N²)           | O(N)             | ধারণাগতভাবে সঠিক, কিন্তু ইমপ্লিমেন্টেশন অদক্ষ। TLE দিতে পারে। |
| **Optimized Greedy**  | **O(N)**        | **O(1)**         | **সর্বোত্তম সমাধান।** কার্যকর, দ্রুত এবং স্পেস-এফিসিয়েন্ট।        |

**ইন্টারভিউতে কীভাবে উপস্থাপন করবেন:**
1.  প্রথমে DP সমাধানটি নিয়ে আলোচনা করুন। এটি দেখাবে যে আপনি একটি ব্রুট-ফোর্স বা স্ট্যান্ডার্ড পদ্ধতিতে সমস্যাটি সমাধান করতে পারেন।
2.  এরপর DP-এর সীমাবদ্ধতা (O(N²) কমপ্লেক্সিটি) উল্লেখ করুন।
3.  তারপর বলুন যে, এই সমস্যাটিকে শর্টেস্ট পাথ হিসেবে দেখা যায় এবং BFS একটি ভালো ধারণা।
4.  অবশেষে, BFS-এর ধারণাটিকে অপ্টিমাইজ করে কীভাবে একটি O(N) Greedy সমাধানে পৌঁছানো যায়, তা বিস্তারিত ব্যাখ্যা করুন। এটি আপনার সমস্যা সমাধানের গভীরতা এবং অপটিমাইজেশন দক্ষতা প্রমাণ করবে।



   


