---

### **Problem Statement**

একটি স্ট্রিং `s` দেওয়া হবে, যা একটি রোমান সংখ্যা (Roman Numeral) নির্দেশ করে। কাজ হলো এই রোমান সংখ্যাটিকে ইন্টিজারে (Integer) রূপান্তর করা।

**রোমান সংখ্যার প্রতীক এবং তাদের মান:**
*   `I` = 1
*   `V` = 5
*   `X` = 10
*   `L` = 50
*   `C` = 100
*   `D` = 500
*   `M` = 1000

**উদাহরণ:**
*   `s = "III"` -> **3** (1 + 1 + 1)
*   `s = "LVIII"` -> **58** (50 + 5 + 1 + 1 + 1)
*   `s = "MCMXCIV"` -> **1994** (1000 + (1000-100) + (100-10) + (5-1))

### **The Core Idea**

রোমান সংখ্যাকে ইন্টিজারে রূপান্তর করার দুটি সাধারণ নিয়ম আছে:

1.  **Addition:** সাধারণত, প্রতীকগুলোর মান বাম থেকে ডানে যোগ করা হয়। যেমন: `VI` = `V` + `I` = 5 + 1 = 6। `XXI` = `X` + `X` + `I` = 10 + 10 + 1 = 21।

2.  **Subtraction:** এখানেই মূল চ্যালেঞ্জটি। যদি একটি **ছোট মানের প্রতীক** একটি **বড় মানের প্রতীকের আগে** বসে, তবে ছোট মানটি বড় মান থেকে বিয়োগ করা হয়।
    *   `IV` = 5 - 1 = 4 (I, V-এর আগে)
    *   `IX` = 10 - 1 = 9 (I, X-এর আগে)
    *   `XL` = 50 - 10 = 40 (X, L-এর আগে)
    *   `XC` = 100 - 10 = 90 (X, C-এর আগে)
    *   `CD` = 500 - 100 = 400 (C, D-এর আগে)
    *   `CM` = 1000 - 100 = 900 (C, M-এর আগে)

এই বিয়োগের নিয়মটিই আমাদের অ্যালগরিদমের মূল ভিত্তি। আমরা যখন স্ট্রিংটি পার্স করব, তখন আমাদের পাশাপাশি দুটি প্রতীকের মান তুলনা করতে হবে।

---

### **Approach 1: Left-to-Right Traversal**

এটি সবচেয়ে স্বাভাবিক পদ্ধতি, কারণ আমরা সাধারণত বাম থেকে ডানেই পড়ি।

**Algorithm Steps:**
1.  **Create a Map:** প্রথমে, প্রতিটি রোমান প্রতীকের জন্য তার ইন্টিজার মান সংরক্ষণ করার জন্য একটি হ্যাশ ম্যাপ (Python-এ ডিকশনারি) তৈরি করো। এটি কোডকে পরিষ্কার এবং সহজবোধ্য করে।
2.  **Initialization:** একটি `total` ভেরিয়েবল নাও এবং এর মান `0` দিয়ে শুরু করো।
3.  **Iteration:** স্ট্রিং `s`-এর উপর দিয়ে বাম থেকে ডানে একটি লুপ চালাও। লুপটি স্ট্রিং-এর **শেষ অক্ষরের আগের অক্ষর** পর্যন্ত চলবে।
4.  **Core Logic:** লুপের ভেতরে, বর্তমান অক্ষর (`s[i]`) এবং তার পরবর্তী অক্ষরের (`s[i+1]`) মান তুলনা করো।
    *   **যদি বিয়োগ হয়:** `value(s[i]) < value(s[i+1])`
        *   এর মানে এটি একটি বিয়োগের ক্ষেত্র (যেমন, 'I' এবং 'V')। এক্ষেত্রে, বর্তমান অক্ষরের মান `total` থেকে **বিয়োগ** করো।
    *   **যদি যোগ হয়:** `value(s[i]) >= value(s[i+1])`
        *   এর মানে এটি একটি সাধারণ যোগের ক্ষেত্র (যেমন, 'V' এবং 'I')। এক্ষেত্রে, বর্তমান অক্ষরের মান `total`-এর সাথে **যোগ** করো।
5.  **শেষ অক্ষর যোগ করা (Adding the Last Character):** লুপটি শেষ হওয়ার পর, স্ট্রিং-এর **একেবারে শেষ অক্ষরটির** মান `total`-এর সাথে যোগ করতে হবে। কারণ, শেষ অক্ষরের পরে তুলনা করার জন্য আর কোনো অক্ষর নেই, তাই এটি সবসময়ই যোগ হয়।

**Python Code:**
```python
def romanToInt(s: str) -> int:
    roman_map = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    }
    
    total = 0
    
    # শেষ অক্ষরের আগের অক্ষর পর্যন্ত লুপ চালাই
    for i in range(len(s) - 1):
        current_val = roman_map[s[i]]
        next_val = roman_map[s[i+1]]
        
        # যদি বর্তমান মান পরের মানের চেয়ে ছোট হয়, বিয়োগ করি
        if current_val < next_val:
            total -= current_val
        # নাহলে যোগ করি
        else:
            total += current_val
            
    # শেষ অক্ষরটি সবসময় যোগ হবে
    total += roman_map[s[-1]]
    
    return total

```

**Complexity Analysis:**
*   **Time Complexity: O(N):** আমরা স্ট্রিংটির উপর দিয়ে মাত্র একবার লুপ চালাই, যেখানে N হলো স্ট্রিং-এর দৈর্ঘ্য।
*   **Space Complexity: O(1):** আমরা একটি হ্যাশ ম্যাপ ব্যবহার করছি, কিন্তু এতে মাত্র ৭টি ধ্রুবক (constant) মান আছে। তাই এটি ইনপুটের আকারের উপর নির্ভরশীল নয়। স্পেস কমপ্লেক্সিটি কনস্ট্যান্ট।

#### **Approach-1: Dry Run (`s = "MCMXCIV"`)**
1.  **Initialization:** `roman_map = {...}`, `total = 0`
2.  **i = 0:** `s[0] = 'M'`, `s[1] = 'C'`.
    *   `1000 >= 100` -> True. `total += 1000`. `total = 1000`.
3.  **i = 1:** `s[1] = 'C'`, `s[2] = 'M'`.
    *   `100 < 1000` -> True. `total -= 100`. `total = 900`.
4.  **i = 2:** `s[2] = 'M'`, `s[3] = 'X'`.
    *   `1000 >= 10` -> True. `total += 1000`. `total = 1900`.
5.  **i = 3:** `s[3] = 'X'`, `s[4] = 'C'`.
    *   `10 < 100` -> True. `total -= 10`. `total = 1890`.
6.  **i = 4:** `s[4] = 'C'`, `s[5] = 'I'`.
    *   `100 >= 1` -> True. `total += 100`. `total = 1990`.
7.  **i = 5:** `s[5] = 'I'`, `s[6] = 'V'`.
    *   `1 < 5` -> True. `total -= 1`. `total = 1989`.
8.  **লুপ শেষ।**
9.  **শেষ অক্ষর যোগ:** `s[-1] = 'V'`. `total += 5`. `total = 1989 + 5 = 1994`।
10. **Result:** `1994`।

---

### **Approach 2: Right-to-Left Traversal**

এটি একটি আরও মার্জিত (elegant) এবং সামান্য সংক্ষিপ্ত পদ্ধতি।

**মূল ধারণা:**
আমরা যদি ডান থেকে বামে যাই, তাহলে আমাদের পরবর্তী অক্ষরের দিকে তাকাতে হবে না। আমরা শুধু বর্তমান অক্ষরের মানকে তার **ডানদিকের অক্ষরের মানের** সাথে তুলনা করব, যা আমরা ইতোমধ্যে প্রসেস করেছি।

**Algorithm Steps:**
1.  **Initialization:** হ্যাশ ম্যাপ তৈরি করো। `total`-এর মান স্ট্রিং-এর **শেষ অক্ষরের মান** দিয়ে শুরু করো।
2.  **Iteration:** স্ট্রিং-এর **শেষ অক্ষরের আগের অক্ষর** থেকে শুরু করে প্রথম অক্ষর পর্যন্ত একটি উল্টো লুপ চালাও।
3.  **Core Logic:** লুপের ভেতরে, বর্তমান অক্ষর (`s[i]`) এবং তার ডানদিকের অক্ষর (`s[i+1]`) এর মান তুলনা করো।
    *   **যদি বিয়োগ হয়:** `value(s[i]) < value(s[i+1])`
        *   বর্তমান মানটি `total` থেকে **বিয়োগ** করো।
    *   **যদি যোগ হয়:** `value(s[i]) >= value(s[i+1])`
        *   বর্তমান মানটি `total`-এর সাথে **যোগ** করো।
4.  **Result:** লুপ শেষে `total`-এর মানই হবে উত্তর।

**Python Code:**
```python
def romanToInt_right_to_left(s: str) -> int:
    roman_map = {
        'I': 1, 'V': 5, 'X': 10, 'L': 50,
        'C': 100, 'D': 500, 'M': 1000
    }
    
    # শেষ অক্ষরের মান দিয়ে শুরু করি
    total = roman_map[s[-1]]
    
    # শেষ অক্ষরের আগের অক্ষর থেকে উল্টো লুপ চালাই
    for i in range(len(s) - 2, -1, -1):
        current_val = roman_map[s[i]]
        next_val = roman_map[s[i+1]]
        
        if current_val < next_val:
            total -= current_val
        else:
            total += current_val
            
    return total
```

**Complexity Analysis:** একই, O(N) টাইম এবং O(1) স্পেস।

---

### **Summary**

*   **মূল চ্যালেঞ্জ:** রোমান সংখ্যার বিয়োগের নিয়মটি সঠিকভাবে হ্যান্ডেল করা।
*   **সেরা সমাধান:** দুটি পদ্ধতিই কার্যকর, তবে বাম থেকে ডানে যাওয়া পদ্ধতিটি সাধারণত বেশি স্বজ্ঞাত। ডান থেকে বামে যাওয়ার পদ্ধতিটি কোড কিছুটা সংক্ষিপ্ত করতে পারে।
*   **ইন্টারভিউ টিপস:** এই সমস্যাটি আপনার কোডিংয়ের স্বচ্ছতা, এজ কেস হ্যান্ডেলিং এবং একটি নির্দিষ্ট নিয়মাবলীকে কোডে রূপান্তর করার ক্ষমতা পরীক্ষা করে। দুটি পদ্ধতির মধ্যে যেকোনো একটি সুন্দরভাবে ব্যাখ্যা করতে পারলেই যথেষ্ট।