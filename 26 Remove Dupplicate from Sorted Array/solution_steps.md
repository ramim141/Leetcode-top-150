### **Problem Statement**

একটি **সর্টেড (sorted)** ইন্টিজার অ্যারে `nums` দেওয়া হবে। কাজ হলো এই অ্যারে থেকে ডুপ্লিকেট সংখ্যাগুলো **ইন-প্লেস (in-place)** সরিয়ে ফেলা, যাতে প্রতিটি ইউনিক উপাদান শুধুমাত্র **একবার** থাকে। উপাদানগুলোর আপেক্ষিক ক্রম (relative order) একই থাকতে হবে।

যেহেতু কিছু ভাষায় অ্যারের দৈর্ঘ্য পরিবর্তন করা সম্ভব নয়, তাই  একটি ইন্টিজার `k` রিটার্ন করতে হবে, যা ডুপ্লিকেট সরানোর পর অ্যারেতে থাকা ইউনিক উপাদানের সংখ্যা নির্দেশ করে। অ্যারে `nums`-এর প্রথম `k`টি ঘরে চূড়ান্ত ফলাফল থাকতে হবে। `k`-এর পরের ঘরগুলোতে কী থাকবে, তা নিয়ে চিন্তা করতে হবে না।

**Example-1:**
*   `nums = [1, 1, 2]`
*   **Result:** `k = 2`, এবং `nums`-এর প্রথম দুটি উপাদান হবে `[1, 2, _]`।

**Example-2:**
*   `nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]`
*   **Result:** `k = 5`, এবং `nums`-এর প্রথম পাঁচটি উপাদান হবে `[0, 1, 2, 3, 4, _, _, _, _, _]`।

### **The Core Challenge**

এই সমস্যার প্রধান চ্যালেঞ্জ হলো **ইন-প্লেস** অপারেশন করা এবং O(1) অতিরিক্ত স্পেস ব্যবহার করে সমাধান করা। যেহেতু অ্যারেটি সর্টেড, তাই ডুপ্লিকেট উপাদানগুলো একসাথে থাকবে। এই বৈশিষ্ট্যটিই আমাদের একটি কার্যকর সমাধান খুঁজে পেতে সাহায্য করবে।

---

### **Approach 1: Using an Extra Data Structure (Brute Force/Sub-optimal)**

যদিও সমস্যাটি in-place করতে বলা হয়েছে, একটি সহজ পদ্ধতি হিসেবে আমরা একটি অতিরিক্ত ডেটা স্ট্রাকচার (যেমন, `std::set` বা একটি অতিরিক্ত `std::vector`) ব্যবহার করতে পারি। এটি একটি ব্রুট-ফোর্স বা সাব-অপ্টিমাল সমাধান, যা ইন্টারভিউতে আলোচনার সূচনা হিসেবে ভালো।

**Core idea:**
1.  অ্যারের সমস্ত উপাদান একটি `std::set`-এ রাখো। `set` স্বয়ংক্রিয়ভাবে ডুপ্লিকেটগুলো বাদ দিয়ে দেবে।
2.  `set`-এর উপাদানগুলোকে আবার মূল `nums` অ্যারেতে কপি করো।

**C++ Code:**
```cpp
#include <iostream>
#include <vector>
#include <set>

int removeDuplicates_extra_space(std::vector<int>& nums) {
    if (nums.empty()) {
        return 0;
    }

    // একটি set এ সব উপাদান রাখলে ডুপ্লিকেট চলে যাবে এবং সর্টেড থাকবে
    std::set<int> unique_elements(nums.begin(), nums.end());
    
    // set থেকে উপাদানগুলো আবার nums vector এ কপি করা
    int k = 0;
    for (int element : unique_elements) {
        nums[k] = element;
        k++;
    }
    
    return k;
}
```

**Complexity Analysis:**
*   **Time Complexity: O(N log N) or O(N):** `std::set`-এ Nটি উপাদান ঢোকাতে O(N log N) সময় লাগে। যদি একটি `std::unordered_set` ব্যবহার করা হয়, তবে গড়ে O(N) সময় লাগবে।
*   **Space Complexity: O(N):** `set`-এ ইউনিক উপাদানগুলো সংরক্ষণের জন্য অতিরিক্ত O(N) স্পেস প্রয়োজন (সবচেয়ে খারাপ ক্ষেত্রে)।

**Verdict:** এটি `in-place` শর্তটি পূরণ করে না এবং টাইম কমপ্লেক্সিটিও সেরা নয়।

---

### **Approach 2: Two Pointers (Optimal and Best Solution)**

এটিই সেরা এবং ইন্টারভিউয়ের জন্য উপযুক্ত সমাধান। যেহেতু অ্যারেটি সর্টেড, আমরা Two-Pointers পদ্ধতি ব্যবহার করে একবার মাত্র ট্র্যাভার্স করে সমাধান করতে পারি।

**Core idea:**
আমরা একটি "write pointer" (ধরা যাক `insert_index` বা `k`) রাখব, যা পরবর্তী ইউনিক উপাদানটি অ্যারের কোথায় লেখা উচিত তা ট্র্যাক করবে। আরেকটি "read pointer" (`i`) পুরো অ্যারেটি ট্র্যাভার্স করে নতুন ইউনিক উপাদান খুঁজে বের করবে।

**Algorithm Steps:**
1.  **Edge Case:** যদি অ্যারে খালি থাকে, `0` রিটার্ন করো।
2.  **Initialization:** একটি `write_pointer` `k` কে `1` দিয়ে শুরু করো। কারণ প্রথম উপাদানটি (`nums[0]`) সবসময়ই ইউনিক এবং তার জায়গায় ঠিক আছে।
3.  **Iteration:** একটি `for` লুপ ব্যবহার করে `read_pointer` `i` কে `1` থেকে অ্যারের শেষ পর্যন্ত চালাও।
4.  **Core Logic:** লুপের ভেতরে, বর্তমান উপাদান `nums[i]`-কে তার **আগের উপাদান** `nums[i-1]`-এর সাথে তুলনা করো।
    *   **যদি `nums[i]` এবং `nums[i-1]` ভিন্ন হয়:**
        *   এর মানে আমরা একটি নতুন ইউনিক উপাদান পেয়েছি।
        *   এই ইউনিক উপাদানটিকে `nums[k]`-তম স্থানে বসাও: `nums[k] = nums[i]`।
        *   `write_pointer` `k`-কে এক ঘর এগিয়ে দাও: `k++`।
    *   **যদি `nums[i]` এবং `nums[i-1]` একই হয়:**
        *   এটি একটি ডুপ্লিকেট। কিছুই করবে না। `read_pointer` `i` স্বাভাবিকভাবেই পরের ঘরে চলে যাবে, কিন্তু `write_pointer` `k` স্থির থাকবে।
5.  **Result:** লুপ শেষ হওয়ার পর, `k`-এর মানই হবে ইউনিক উপাদানের সংখ্যা।

**C++ Code:**
```cpp
#include <iostream>
#include <vector>

int removeDuplicates(std::vector<int>& nums) {
    // Edge case: যদি vector খালি হয়
    if (nums.empty()) {
        return 0;
    }

    // k হলো write pointer. প্রথম উপাদানটি 항상ই ঠিক জায়গায় থাকে,
    // তাই k=1 থেকে শুরু।
    int k = 1;

    // i হলো read pointer, যা দ্বিতীয় উপাদান থেকে শুরু করবে
    for (int i = 1; i < nums.size(); ++i) {
        // যদি একটি নতুন ইউনিক উপাদান পাওয়া যায়
        if (nums[i] != nums[i - 1]) {
            // সেটিকে k-তম স্থানে বসাই
            nums[k] = nums[i];
            // এবং k-কে পরের ঘরের জন্য প্রস্তুত করি
            k++;
        }
    }
    
    return k;
}

// Main function for testing
int main() {
    std::vector<int> nums1 = {1, 1, 2};
    int k1 = removeDuplicates(nums1);
    std::cout << "k = " << k1 << ", nums = [";
    for (int i = 0; i < k1; ++i) {
        std::cout << nums1[i] << (i == k1 - 1 ? "" : ", ");
    }
    std::cout << "]" << std::endl;

    std::vector<int> nums2 = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};
    int k2 = removeDuplicates(nums2);
    std::cout << "k = " << k2 << ", nums = [";
    for (int i = 0; i < k2; ++i) {
        std::cout << nums2[i] << (i == k2 - 1 ? "" : ", ");
    }
    std::cout << "]" << std::endl;

    return 0;
}
```

**Complexity Analysis:**
*   **Time Complexity: O(N):** আমরা অ্যারেটি একবার মাত্র ট্র্যাভার্স করি।
*   **Space Complexity: O(1):** আমরা কোনো অতিরিক্ত অ্যারে বা ডেটা স্ট্রাকচার ব্যবহার করিনি।

**Verdict:** এটিই **সর্বোত্তম সমাধান**, যা `in-place` শর্ত পূরণ করে এবং লিনিয়ার টাইমে কাজ করে।

#### **Approach-2: Dry Run (`nums = [0, 0, 1, 1, 1, 2]`)**

| `i` | `nums[i]` | `nums[i-1]` | `nums[i] != nums[i-1]`? | Action | `k` | `nums`  |
|---|---|---|---|---|---|---|
| - | - | - | - | - | 1 | `[0, 0, 1, 1, 1, 2]` |
| 1 | 0 | 0 | `0 != 0` -> False | (কিছুই না) | 1 | `[0, 0, 1, 1, 1, 2]` |
| 2 | 1 | 0 | `1 != 0` -> True | `nums[1] = 1`, `k++` | 2 | `[0, 1, 1, 1, 1, 2]` |
| 3 | 1 | 1 | `1 != 1` -> False | (কিছুই না) | 2 | `[0, 1, 1, 1, 1, 2]` |
| 4 | 1 | 1 | `1 != 1` -> False | (কিছুই না) | 2 | `[0, 1, 1, 1, 1, 2]` |
| 5 | 2 | 1 | `2 != 1` -> True | `nums[2] = 2`, `k++` | 3 | `[0, 1, 2, 1, 1, 2]` |

**Final Result:** `k = 3`। `nums`-এর প্রথম ৩টি উপাদান: `[0, 1, 2]`।