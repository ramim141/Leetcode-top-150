---

### **Problem Statement**

একটি ইন্টিজার `num` দেওয়া হবে। কাজ হলো এই সংখ্যাটিকে তার সমতুল্য রোমান সংখ্যায় (Roman Numeral) রূপান্তর করে একটি স্ট্রিং হিসেবে রিটার্ন করা।

**রোমান সংখ্যার প্রতীক এবং তাদের মান:**
*   `I`=1, `V`=5, `X`=10, `L`=50, `C`=100, `D`=500, `M`=1000

**বিশেষ বিয়োগের নিয়ম:**
*   `IV` = 4, `IX` = 9
*   `XL` = 40, `XC` = 90
*   `CD` = 400, `CM` = 900

**উদাহরণ:**
*   `num = 3` -> `"III"`
*   `num = 58` -> `"LVIII"` (L=50, V=5, III=3)
*   `num = 1994` -> `"MCMXCIV"` (M=1000, CM=900, XC=90, IV=4)

### **Integer to Roman বনাম Roman to Integer**

*   **Roman to Integer (LC 13):** এখানে আমরা একটি স্ট্রিং **পার্স (parse)** করে একটি সংখ্যা তৈরি করি। চ্যালেঞ্জ ছিল বিয়োগের নিয়মটি শনাক্ত করা।
*   **Integer to Roman (LC 12):** এখানে আমরা একটি সংখ্যা থেকে একটি স্ট্রিং **তৈরি (build)** করি। চ্যালেঞ্জ হলো কখন সাধারণ প্রতীক (V, L, D) এবং কখন বিয়োগের প্রতীক (IV, XL, CD) ব্যবহার করতে হবে, সেই সিদ্ধান্ত নেওয়া।

### **The Core Idea**

এই সমস্যা সমাধানের সবচেয়ে কার্যকর উপায় হলো একটি **Greedy** অ্যাপ্রোচ। আমরা প্রদত্ত সংখ্যা থেকে সবচেয়ে বড় সম্ভাব্য রোমান সংখ্যার মান বিয়োগ করতে থাকব এবং সংশ্লিষ্ট প্রতীকটি আমাদের ফলাফলে যোগ করতে থাকব, যতক্ষণ না সংখ্যাটি শূন্য হয়ে যায়।

**গুরুত্বপূর্ণ কৌশল:** Greedy অ্যাপ্রোচটি সঠিকভাবে কাজ করানোর জন্য, আমাদের অবশ্যই **বিয়োগের প্রতীকগুলোকেও** আমাদের তালিকার অন্তর্ভুক্ত করতে হবে। যেমন, `900` (`CM`) কে `500` (`D`) এর আগে বিবেচনা করতে হবে। নাহলে, `900` কে আমরা `DCD` (500 + 400) হিসেবে ভুলভাবে প্রকাশ করতে পারি।

---

### **Approach 1: The Greedy Approach (সেরা সমাধান)**

এটি সবচেয়ে মার্জিত এবং সাধারণ অ্যালগরিদমিক সমাধান।

**Algorithm Steps:**
1.  **Create Value-Symbol Maps:** দুটি লিস্ট তৈরি করো। একটিতে রোমান সংখ্যার মানগুলো **বড় থেকে ছোট** ক্রমে থাকবে এবং অন্যটিতে সংশ্লিষ্ট প্রতীকগুলো থাকবে। অবশ্যই বিয়োগের ক্ষেত্রগুলোও অন্তর্ভুক্ত করতে হবে।
    *   `values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]`
    *   `symbols = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]`
2.  **Initialization:** একটি খালি স্ট্রিং `result` নাও, যেখানে আমরা আমাদের উত্তর তৈরি করব।
3.  **Greedy Loop:** `values` লিস্টের উপর দিয়ে একটি লুপ চালাও।
4.  **Core Logic:** লুপের ভেতরে, বর্তমান মান (`value`) যতক্ষণ পর্যন্ত আমাদের `num`-এর চেয়ে ছোট বা সমান থাকবে, ততক্ষণ:
    *   `num` থেকে `value` বিয়োগ করো।
    *   `result` স্ট্রিং-এর সাথে সংশ্লিষ্ট `symbol` যোগ করো।
5.  **Result:** যখন `num` শূন্য হয়ে যাবে (বা বাইরের লুপ শেষ হবে), `result` স্ট্রিংটিই হবে আমাদের উত্তর।

**Python Code:**
```python
def intToRoman(num: int) -> str:
    # বড় থেকে ছোট ক্রমে মান এবং প্রতীক
    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    symbols = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
    
    result = []
    
    # প্রতিটি মানের জন্য লুপ চালাই
    for i in range(len(values)):
        # যতক্ষণ বর্তমান মান num-এর মধ্যে থাকবে
        while num >= values[i]:
            # num থেকে মানটি বিয়োগ করি
            num -= values[i]
            # এবং সংশ্লিষ্ট প্রতীক ফলাফলে যোগ করি
            result.append(symbols[i])
            
    return "".join(result)
```

**Complexity Analysis:**
*   **Time Complexity: O(1):** যদিও এখানে লুপ আছে, ইনপুট সংখ্যা (`num`) 1 থেকে 3999-এর মধ্যে সীমাবদ্ধ। `values` লিস্টের আকারও ধ্রুবক (13)। `while` লুপটি প্রতিটি মানের জন্য সর্বোচ্চ কয়েকবার (যেমন, 3-এর জন্য `I` তিনবার) চলে। তাই মোট অপারেশনের সংখ্যা ইনপুটের আকারের উপর নির্ভর করে না, এটি ধ্রুবক।
*   **Space Complexity: O(1):** `result` স্ট্রিং-এর সর্বোচ্চ দৈর্ঘ্যও সীমিত (যেমন, 3999 = `MMMCMXCIX`), তাই এটিও ধ্রুবক।

#### **Approach-1: Dry Run (`num = 1994`)**
| `value` | `symbol` | `num` (শুরুতে) | `num >= value`? | `num` (শেষে) | `result` (শেষে) |
|---|---|---|---|---|---|
| - | - | 1994 | - | 1994 | [] |
| 1000 | "M" | 1994 | True | 994 | ["M"] |
| 900 | "CM" | 994 | True | 94 | ["M", "CM"] |
| 500 | "D" | 94 | False | 94 | ["M", "CM"] |
| 400 | "CD" | 94 | False | 94 | ["M", "CM"] |
| 100 | "C" | 94 | False | 94 | ["M", "CM"] |
| 90 | "XC" | 94 | True | 4 | ["M", "CM", "XC"] |
| 50 | "L" | 4 | False | 4 | ["M", "CM", "XC"] |
| 40 | "XL" | 4 | False | 4 | ["M", "CM", "XC"] |
| 10 | "X" | 4 | False | 4 | ["M", "CM", "XC"] |
| 9 | "IX" | 4 | False | 4 | ["M", "CM", "XC"] |
| 5 | "V" | 4 | False | 4 | ["M", "CM", "XC"] |
| 4 | "IV" | 4 | True | 0 | ["M", "CM", "XC", "IV"] |
| 1 | "I" | 0 | False | 0 | ["M", "CM", "XC", "IV"] |

**Final Result:** `"".join(["M", "CM", "XC", "IV"])` -> `"MCMXCIV"`।

---

### **Approach 2: Place Value Method**

এই পদ্ধতিতে আমরা সংখ্যাটিকে তার স্থানিক মান (হাজার, শতক, দশক, একক) অনুযায়ী ভাগ করে প্রতিটি ভাগের জন্য রোমান সংখ্যা বের করি।

**Core concept:**
`1994 = 1000 + 900 + 90 + 4`। আমরা প্রতিটি ভাগের জন্য আলাদাভাবে রোমান সংখ্যা বের করে শেষে জুড়ে দেব।

**Algorithm Steps:**
1.  **Create Value-Symbol Maps:** প্রতিটি স্থানিক মানের (1-9) জন্য রোমান প্রতীকগুলোর একটি হার্ডকোডেড লিস্ট তৈরি করো।
    *   `ones = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"]`
    *   `tens = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"]`
    *   `hundreds = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"]`
    *   `thousands = ["", "M", "MM", "MMM"]`
2.  **মান বের করা:** `num` থেকে প্রতিটি স্থানিক মানের সংখ্যা বের করো।
    *   হাজারের ঘরের জন্য: `num // 1000`
    *   শতকের ঘরের জন্য: `(num % 1000) // 100`
    *   দশকের ঘরের জন্য: `(num % 100) // 10`
    *   এককের ঘরের জন্য: `num % 10`
3.  **ফলাফল তৈরি:** প্রতিটি ঘরের জন্য সংশ্লিষ্ট লিস্ট থেকে প্রতীক নিয়ে জুড়ে দাও।

**Python Code:**
```python
def intToRoman_place_value(num: int) -> str:
    ones = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"]
    tens = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"]
    hundreds = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"]
    thousands = ["", "M", "MM", "MMM"]
    
    return (thousands[num // 1000] +
            hundreds[(num % 1000) // 100] +
            tens[(num % 100) // 10] +
            ones[num % 10])

```

**Complexity Analysis:** একই, O(1) টাইম এবং O(1) স্পেস।

#### **Approach-2: Dry Run (`num = 1994`)**
1.  `thousands[1994 // 1000]` -> `thousands[1]` -> `"M"`
2.  `hundreds[(1994 % 1000) // 100]` -> `hundreds[994 // 100]` -> `hundreds[9]` -> `"CM"`
3.  `tens[(1994 % 100) // 10]` -> `tens[94 // 10]` -> `tens[9]` -> `"XC"`
4.  `ones[1994 % 10]` -> `ones[4]` -> `"IV"`
5.  **Result:** `"M" + "CM" + "XC" + "IV"` -> `"MCMXCIV"`।

---

### **Summary**

| Approach  | Time Complexity | Space Complexity | Verdict  |
| :--- | :--- | :--- | :--- |
| **Greedy Approach** | **O(1)** | **O(1)** | **সর্বোত্তম এবং মার্জিত সমাধান।** এটি একটি সাধারণ অ্যালগরিদমিক প্যাটার্ন দেখায়। |
| **Place Value Method**| O(1) | O(1) | কার্যকর এবং দ্রুত, কিন্তু কিছুটা বেশি হার্ডকোডিং প্রয়োজন। |

**ইন্টারভিউ টিপস:**
*   **Greedy Approach** সাধারণত বেশি প্রশংসিত হয় কারণ এটি একটি সাধারণ অ্যালগরিদমিক কৌশল প্রদর্শন করে যা অন্য সমস্যাতেও প্রয়োগ করা যায়।
*   ব্যাখ্যা করার সময়, অবশ্যই উল্লেখ করবে কেন `values` লিস্টটি বড় থেকে ছোট ক্রমে সাজানো এবং কেন বিয়োগের ক্ষেত্রগুলো (`900`, `400` ইত্যাদি) অন্তর্ভুক্ত করা অপরিহার্য। এটি আপনার গভীর চিন্তাভাবনার প্রমাণ দেবে।