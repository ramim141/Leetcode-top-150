
### **Problem Statement**

তোমাকে দুটি ইন্টিজার অ্যারে `nums1` এবং `nums2` দেওয়া হবে, যারা উভয়ই **নন-ডিক্রিসিং (non-decreasing)** ক্রমে সাজানো। এছাড়াও দুটি ইন্টিজার `m` এবং `n` দেওয়া হবে, যা যথাক্রমে `nums1` এবং `nums2`-তে থাকা উপাদানের সংখ্যা নির্দেশ করে।

কাজ হলো `nums1` এবং `nums2`-কে মার্জ করে একটি একক, সাজানো অ্যারে তৈরি করা, যা `nums1`-এর মধ্যেই সংরক্ষিত থাকবে।

**Important:**
*   `nums1` অ্যারেটির মোট দৈর্ঘ্য `m + n`। এর প্রথম `m`টি উপাদান হলো আসল ডেটা এবং পরের `n`টি উপাদান হলো `0`, যা `nums2`-এর উপাদানগুলোর জন্য জায়গা হিসেবে কাজ করে।
*   সমাধানটি অবশ্যই **in-place** হতে হবে।

**Example:**
*   `nums1 = [1, 2, 3, 0, 0, 0]`, `m = 3`
*   `nums2 = [2, 5, 6]`, `n = 3`
*   **Result:** `nums1` অ্যারেটি পরিবর্তিত হয়ে হবে `[1, 2, 2, 3, 5, 6]`।

### **The Core Challenge**

এই সমস্যার প্রধান চ্যালেঞ্জ হলো **ইন-প্লেস** মার্জ করা। আমরা যদি অ্যারের শুরু থেকে মার্জ করার চেষ্টা করি, তাহলে `nums1`-এর মূল উপাদানগুলো ওভাররাইট (overwrite) হয়ে যাওয়ার ঝুঁকি থাকে। যেমন, `nums1` এর `1` এবং `nums2` এর `2` তুলনা করলে `1` ঠিক জায়গায় আছে। কিন্তু `nums1`-এর `2` এবং `nums2`-এর `2` তুলনা করার পর, যদি আমরা `nums2`-এর `2`-কে `nums1`-এ ঢোকাতে চাই, তাহলে `nums1`-এর মূল `3`-কে সরাতে হবে, যা একটি জটিল এবং অদক্ষ প্রক্রিয়া।

---

### **Approach 1: Merge and Sort**

এটি সবচেয়ে সহজবোধ্য এবং ব্রুট-ফোর্স সমাধান।

**Core concept:**
প্রথমে `nums2`-এর উপাদানগুলোকে `nums1`-এর শেষে থাকা `0`-গুলোর জায়গায় বসিয়ে দাও। তারপর পুরো `nums1` অ্যারেটিকে সর্ট করে ফেলো।

**Algorithm Step:**
1.  `nums2`-এর `n`টি উপাদানকে `nums1`-এর `m`-তম ইনডেক্স থেকে শুরু করে কপি করো।
2.  Python-এর বিল্ট-ইন `sort()` ফাংশন ব্যবহার করে `nums1` অ্যারেটিকে সর্ট করো।

**Python Code:**
```python
def merge_and_sort(nums1: list[int], m: int, nums2: list[int], n: int):
    # ধাপ ১: nums2-কে nums1-এর শেষে কপি করা
    for i in range(n):
        nums1[m + i] = nums2[i]
    
    # ধাপ ২: পুরো অ্যারে সর্ট করা
    nums1.sort()
```

**Complexity Analysis:**
*   **Time Complexity: O((m+n) log(m+n)):** `sort()` ফাংশনটি সাধারণত Timsort বা IntroSort ব্যবহার করে, যার টাইম কমপ্লেক্সিটি O(N log N), যেখানে N হলো মোট উপাদানের সংখ্যা (`m+n`)।
*   **Space Complexity: O(N) বা O(log N):** Python-এর Timsort সবচেয়ে খারাপ ক্ষেত্রে O(N) স্পেস ব্যবহার করতে পারে। তাই এটি কঠোরভাবে O(1) স্পেস নয়।

**Verdict:** এটি কাজ করে, কিন্তু ইন্টারভিউয়ার এটি গ্রহণ করবেন না, কারণ এটি অ্যারে দুটির "সর্টেড" হওয়ার বৈশিষ্ট্যকে কোনো কাজেই লাগায় না এবং বিল্ট-ইন ফাংশনের উপর নির্ভরশীল।

---

### **Approach 2: Two Pointers from the End**

এই পদ্ধতিতে আমরা "ইন-প্লেস" চ্যালেঞ্জটি একটি চতুর উপায়ে সমাধান করি: **শেষ থেকে মার্জ করা শুরু করে**।

**Core concept:**
যেহেতু `nums1`-এর অতিরিক্ত জায়গাটি শেষে রয়েছে, তাই আমরা যদি `nums1`-এর শেষ ঘর থেকে পূরণ করা শুরু করি, তাহলে আমরা কোনো ডেটা ওভাররাইট না করেই মার্জ করতে পারব।

**Algorihm Steps:**
1.  **তিনটি পয়েন্টার নাও:**
    *   `p1`: `nums1`-এর শেষ *আসল* উপাদানের ইনডেক্স (`m - 1`)।
    *   `p2`: `nums2`-এর শেষ উপাদানের ইনডেক্স (`n - 1`)।
    *   `p` (বা `write_pointer`): `nums1`-এর একেবারে শেষ ঘরের ইনডেক্স (`m + n - 1`)। এটি হলো আমাদের "রাইট" পয়েন্টার।
2.  **মার্জ লুপ:** যতক্ষণ `p1` এবং `p2` উভয়ই বৈধ থাকে (অর্থাৎ `>= 0`), ততক্ষণ একটি `while` লুপ চালাও।
3.  **Core Logic:** `nums1[p1]` এবং `nums2[p2]`-এর মধ্যে তুলনা করো:
    *   **যদি `nums1[p1]` বড় হয়:** `nums1[p]`-তে `nums1[p1]`-এর মান বসাও এবং `p1`-কে এক ঘর কমাও।
    *   **নাহলে (যদি `nums2[p2]` বড় বা সমান হয়):** `nums1[p]`-তে `nums2[p2]`-এর মান বসাও এবং `p2`-কে এক ঘর কমাও।
    *   প্রতিটি ধাপে `p`-কে এক ঘর কমাও।
4.  **বাকি উপাদান (Edge Case):** লুপ শেষ হওয়ার পর, হতে পারে `nums2`-তে এখনও কিছু উপাদান বাকি আছে (কারণ `p1` আগে `0`-এর নিচে চলে গেছে)। এই বাকি উপাদানগুলো `nums1`-এর চেয়েও ছোট, তাই এদেরকে `nums1`-এর শুরুতে কপি করে দাও।
    *   **দ্রষ্টব্য:** যদি `nums1`-এ উপাদান বাকি থাকে, তবে তাদের নিয়ে চিন্তা করার দরকার নেই, কারণ তারা ইতোমধ্যে সঠিক জায়গায় আছে।

**Python Code:**
```python
def merge_optimal(nums1: list[int], m: int, nums2: list[int], n: int):
    # p1: nums1-এর শেষ উপাদানের পয়েন্টার
    p1 = m - 1
    # p2: nums2-এর শেষ উপাদানের পয়েন্টার
    p2 = n - 1
    # p: nums1-এর শেষ ঘরের পয়েন্টার (যেখানে লেখা হবে)
    p = m + n - 1
    
    # শেষ থেকে মার্জ করা শুরু
    while p1 >= 0 and p2 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
        
    # যদি nums2-তে কোনো উপাদান বাকি থাকে
    # (p1 < 0 হয়ে গেলে এই লুপটি চলবে)
    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1
```

**Complexity Analysis:**
*   **Time Complexity: O(m+n):** প্রতিটি উপাদান (`m+n`টি) একবার করেই দেখা এবং বসানো হয়।
*   **Space Complexity: O(1):** আমরা কোনো অতিরিক্ত অ্যারে ব্যবহার করিনি, শুধুমাত্র কয়েকটি পয়েন্টার ব্যবহার করেছি।

#### **Approach-2: Dry Run (`nums1 = [1,2,3,0,0,0]`, `m=3`, `nums2 = [2,5,6]`, `n=3`)**

| `p1` | `p2` | `p` | `nums1[p1]` | `nums2[p2]` | Condition | Action | `nums1` (অবস্থা) |
|---|---|---|---|---|---|---|---|
| 2 | 2 | 5 | 3 | 6 | `3 < 6` | `nums1[5] = 6`, `p2--` | `[1,2,3,0,0,6]` |
| 2 | 1 | 4 | 3 | 5 | `3 < 5` | `nums1[4] = 5`, `p2--` | `[1,2,3,0,5,6]` |
| 2 | 0 | 3 | 3 | 2 | `3 > 2` | `nums1[3] = 3`, `p1--` | `[1,2,3,3,5,6]` |
| 1 | 0 | 2 | 2 | 2 | `2 <= 2` | `nums1[2] = 2`, `p2--` | `[1,2,2,3,5,6]` |

এখন `p2` হয়ে গেছে `-1`। `while p1 >= 0 and p2 >= 0` লুপটি শেষ।
পরের `while p2 >= 0` লুপটি চলবে না কারণ `p2` আর `>= 0` নয়।
**Final Result:** `[1, 2, 2, 3, 5, 6]`।

---

### **Summary of Approaches**

| Approach  | Time Complexity | Space Complexity | Verdict  |
| :--- | :--- | :--- | :--- |
| **Merge and Sort** | O((m+n) log(m+n)) | O(N) / O(log N) | সহজবোধ্য কিন্তু অদক্ষ এবং `in-place` শর্ত ঠিকভাবে মানে না। |
| **Two Pointers from End** | **O(m+n)** | **O(1)** | **সর্বোত্তম সমাধান।** কার্যকর, দ্রুত এবং `in-place` শর্ত পূরণ করে। |